## JDBC란

JDBC(Java DataBase Connectivity)는 자바 프로그램에서 Database를 조작하게 해주는 API이다.
JDBC API는 JDK에서 제공하며 JDBC 프로그래밍을 위해서는 JDBC드라이버가 필요하다. 
JDBC 드라이버는 각 DBMS 회사에서 제공하는 라이브러리 압축파일이다. 
이번 체스 미션에서는 MySQL을 사용하기 때문에, MySQL 드라이버를 사용했다.



![image](https://user-images.githubusercontent.com/67885363/162207853-e28cc639-7c5c-41f6-9b29-65d969639e88.png)



### JDBD API 클래스

JDBC 클래스와 인터페이스는 자바 패키지 java.sql과 javax.sql에 포함되어 있다.

![image](https://user-images.githubusercontent.com/67885363/162208272-33c76821-16ac-4c9d-8271-a0f5e26b2d16.png)



### JDBC를 이용한 데이터베이스 연동과정

- JDBC 드라이버 로드

```java
    private void loadDriver() {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (final Exception e) {
            e.printStackTrace();
        }
    }
```

`Class.forName("com.mysql.cj.jdbc.Driver")` 를 호출하여, mysql에서 제공하는 Driver 클래스를 JVM method area에 로딩시킨다.



- 데에터베이스 연결

```java
    private static final String URL = "jdbc:mysql://localhost:3307/chess";
    private static final String USER = "user";
    private static final String PASSWORD = "password";
    
		public Connection getConnection() {
        loadDriver();
        Connection connection = null;
        try {
            connection = DriverManager.getConnection(URL, USER, PASSWORD);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return connection;
    }
	
```

URL에는 MySQL의 포트번호와 데이터베이스 이름을 지정해주면 된다.
로컬 환경에서 MySQL의 포트번호는 3306이다. 
체스 미션에서는 docker 환경에서 MySQL 을 사용했기 때문에, 포트를 3307로 지정해주었다. (저는 기존에 따로, 로컬 환경에서 3306 포트를 사용하고 있었습니다.)

이제 Connection 객체를 만들어 사용하게 되는데, DriverManager의 getConnection() 을 호출해서, MySQL에 연결하기 위한 커넥션 정보를 입력한다.
Connection 객체가 만들어지면, Query 문을 실행시키는 statement 객체를 생성할 수 있다.



- Statement 객체 생성

```java
    public void save(String position, String piece, String color, int gameId) {
        Connection connection = getConnection();
        final String sql = "insert into board (position, piece, color, game_id) values (?, ?, ?, ?)";
        try (PreparedStatement statement = connection.prepareStatement(sql)) {
            statement.setString(1, position);
            statement.setString(2, piece);
            statement.setString(3, color);
            statement.setInt(4, gameId);
            statement.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
```

Statement는 Connection으로 연결한 객체에게, SQL 질의문을 전달하는 역할을 한다.
Statement는 정적인 쿼리문을 처리할 수 있으므로, 쿼리문에 값이 미리 입력되어 있어야 한다.

위에 코드에서는, PreparedStatement를 사용하고 있는데, PreparedStaement는 뭘까?
PreparedStatement는 Statement를 상속하고 있는 인터페이스다.

그럼 Statement와 PreparedStatement의 차이가 뭘까?
PreparedStatement는 SQL문장이 미리 컴파일되고, 실행 시간동안 인수값을 위한 공간을 확보할 수 있다는 점에서 Statement 객체와 다르다. 
Statement 객체의 SQL은 실행될 때 매번 서버에서 분석해야 하는 반면, PreparedStatement 객체는 한 번 분석되면 재사용이 용이하다.
각각의 인수에 대해 위치홀더(placeholder)를 사용하여 SQL문장을 정의할 수 있게 해준다. 위치홀더는 ? 로 표현된다.
동일한 SQL문을 특정 값만 바꾸어서 여러 번 실행해야 할 때, 인수가 많아서 SQL문을 정리해야 될 필요가 있을 때 사용하면 유용하다.



**1.준비(Prepare): 먼저 애플리케이션은 문의 틀을 만들고 이를 DBMS로 보낸다. 특정값은 지정하지 않은 채로 남겨진다** 

**2.그 다음, DBMS는 문의 틀을 컴파일하며(최적화 및 변환) 아직 실행하지 않고 결과만 저장한다.**

 

**3.실행(Execute): 나중에 애플리케이션이 문 틀의 변수에 값(바인드)을 지정하면 DBMS는 (결과를 반환할 수도 있는) 문을 실행한다. 애플리케이션은 여러 값으로 원하는 횟수만큼 문을 실행할 수 있다. 위의 예에서 첫 번째 변수로 "bike"로, 두 번째 변수로 "20"을 지정한다.**

 

Statement와 PreparedStatement차이는 무엇일까?

Statement와 PreparedStatement의 아주 큰 차이는 바로 캐시(cache)사용여부이다.

 

Statement를 사용하면 매번 쿼리를 수행할 때마다 4단계를 거치게 되고(계속적으로 단계를 거치면서 수행)

PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아 재사용을 한다는 것이다. 만약 동일한 쿼리를 반복적으로 수행한다면 PreparedStatment가 DB에 훨씬 적은 부하를 주며, 성능도 좋다.





- SQL문 수행

- Result 객체로부터 데이터를 추출
- Resultset Close
- Statement 객체 close
- Connection 객체 close



