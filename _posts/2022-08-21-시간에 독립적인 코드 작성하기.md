---
title: 시간에 독립적인 테스트를 위한 코드 작성하기
categories:
  - spring
  - test
  - checkmate
date: 2022-08-21
---

지금 진행하고 있는 프로젝트인 체크메이트는 출결 관리 서비스입니다. 
출석이라는 도메인 자체가 시간과 밀접해있기 때문에 시간에 따라 도메인의 상태가 많이 변경하게 됩니다.

예를 들어, 미팅 시작 시간 30분 전부터 미팅 시작 시간 5분 후 까지는 출석부가 수정이 허용이 되고, 출석 허용시간이 끝나면 출결 상태가 지각으로 바뀌어야 하는 등 기능 요구사항들과 시간이 굉장히 밀접하다는 것을 확인할 수 있습니다.

시간과 밀접한 기능에 대한 로직을 작성할 때,  `LocalDateTime.now()`(요청이 들어오는 시간) 를 이용하게 되니 시간에 따라 테스트의 성공 여부가 달라지게 되었고 시간에 의존적이지 않은 테스트 코드를 작성하기 위해 고민하게 되었습니다.

<br/> 

시간에 따라 테스트가 실패했던 예시에 대해 살펴보겠습니다.

아래의 코드는 출석체크 하는 기능으로 전체적인 플로우에 대해 설명을 해보자면,

- meetingId와 UserId에 대해 존재하는 id인지 확인한다.
- 조회하려는 날짜에 미팅의 이벤트가 있는지 확인한다. (위 그림의 빨간색 부분 -> 테스트를 실패하게 했던 요인)
  - 요청을 보내는 날짜에 미팅의 이벤트가 존재하지 않으면 예외를 발생한다.
- 일정이 있는 경우에 참가자에 대한 출석처리를 한다.

![image](https://user-images.githubusercontent.com/67885363/197393566-17ae8e73-fe15-40d2-86e9-a835c59a1791.png)

테스트를 수행하는 시간에 따라,  `LocalDate.now`의 값이 변경하게 되면서 시간에 매우 의존적인 상황이였습니다.
예를 들어, 데이터 베이스에 2022년 8월 21일의 일정만 저장되어 있다면, 2022년 8월 21일에만 테스트 코드를 수행해야 이벤트가 조회되면서 테스트를 성공 시킬 수 있었습니다.



<br/>

실패했던 테스트 코드에 대해서 살펴보겠습니다.


![image](https://user-images.githubusercontent.com/67885363/197397021-9cc1cf01-45f9-4488-8c2e-c04169c09a1e.png)

위 테스트 코드에서 이벤트 객체는 2022년 8월 1일로 저장하였습니다.
현재 프로덕션 코드에서는 `LocalDate.now`로 조회를 하고 있기 때문에 테스트 돌리는 날짜에 따라 이벤트를 조회하는 날짜가 달라지게 되었고 아래의 테스트 코드는 2022년 8월 1일에만 통과하게 되었습니다.



이 문제를 해결하기 위해 요청 시간을 관리하는 객체를 만들어, 테스트 클래스에서는 가짜 객체를 주입받아 시간을 지정할 수 있게 하고자 하였습니다. 



<br/> 

먼저 LocalDateTime을 필드로 가지는 DateTime이라는 추상 클래스를 만들었습니다.
![image](https://user-images.githubusercontent.com/67885363/197398112-3ee581ad-0142-48f0-aa5b-28d14f8ab581.png)



- 프로덕션 코드에서는 ServerDateTime이라는 객체를 사용되게 하고자 했고
![image](https://user-images.githubusercontent.com/67885363/197401384-e441154a-496b-4b08-9379-f439073125e8.png)




- 테스트 코드에서는 FakeDateTime 객체가 사용되게 하고자 했습니다. 그러기 위해서 이 FakeDateTime의 객체 위치를 test 패키지 하위에 배치했고, @Primary 어노테이션이 붙여주었습니다.



> **테스트를 수행할 때 어떻게 FakeDateTime으로 주입받게 하였나?**
>
> DateTime을 의존하고 있는 빈이 만들어질 때, 맨 처음에는 main 패키지에 존재하는 ServerDateTime을 주입받아 빈이 구성이 되지만,
>
> test 패키지를 빌드하면서 @Primary가 붙어 있는 FakeDateTime이 ServerDateTime의 빈을 덮어씌우게 하였습니다.



![image](https://user-images.githubusercontent.com/67885363/197398309-1ac7653b-2e04-4e29-90a8-e5126efd049f.png)



<br/> 

그리고 이 DateTime 빈은 `LocalDateTime`이라는 상태를 가지고 있기 때문에, 상태가 다른 스레드에서도 공유되지 않게 해야했습니다.

그래서 빈 스코프를 prototype으로 할지, request로 할 지 고민이 들었는데 request가 더 간편해서 request로 결정하게 되었습니다.

> 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 주의할 점
>
> 그리고 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 처음 주입받은 프로토타입 빈과 함께 계속 유지된다. (프로토타입 빈은 컨테이너가 빈을 생성하고 초기화할 때까지만 관리하고 종료 시점까지 관리하지 않는다. )
>
> 그래서 프로토타입 빈을 사용할 때마다 ApplicationContext에서 직접 조회하는 로직이 수행되어야 하는데, 이런 것들을 간편하게 해주는 Provider 같은 라이브러리를 사용해야 한다.
>
> 반면 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리한다.

 

그리고 이 DateTime을 필드로 가지고 있고 시간에 관련된 비즈니스 로직을 처리하는 ServerTimeManager라는 객체를 만들어 반복되는 로직에 대해 중복을 최소화했습니다.

![image](https://user-images.githubusercontent.com/67885363/197399128-ad71fedd-d312-49b0-9ebb-85ef18b41a93.png)


