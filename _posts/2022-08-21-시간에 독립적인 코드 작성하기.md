---
title: 시간에 독립적인 테스트를 위한 코드 작성하기
categories:
  - spring
  - test
  - checkmate
date: 2022-08-21
---

지금 진행하고 있는 프로젝트인 체크메이트는 출결 관리 서비스이다. 출석이라는 도메인 자체가 시간과 밀접해있기 때문에 시간에 따라 도메인의 상태가 많이 변경된다. 
예를 들어, 미팅 시작 시간 30분 전부터 미팅 시작 시간 5분 후 까지는 출석부가 수정이 허용되고, 출석 허용시간이 끝나면 출결 상태가 출석이 아닌 회원들은 지각으로 바뀌어야 하는 등 기능의 요구사항들과 시간이 굉장히 밀접하다.

시간과 밀접한 기능에 대한 로직을 작성할 때,  `LocalDateTime.now()`(요청이 들어오는 시간) 를 이용하게 되니 시간에 따라 테스트의 성공 여부가 달라지게 되었고 시간에 의존적이지 않은 테스트 코드를 작성하기 위해 고민하게 되었다.

<br/> 


하나의 예시에 대해 살펴보겠다. 아래의 코드는 출석체크를 하는 메서드인데 코드를 간단하게 설명을 하자면,
![image](https://user-images.githubusercontent.com/67885363/197393566-17ae8e73-fe15-40d2-86e9-a835c59a1791.png)

- pathVariable로 받는 meetingId와 UserId에 대해 존재하는 id인지 확인한다.
- 요청을 보내는 날짜에 미팅의 이벤트가 있는지 확인하고 일정이 있으면 참가자에 대한 출석처리를 한다.
- 요청을 보내는 날짜에 미팅의 이벤트가 존재하지 않으면 예외를 발생한다.


![image](https://user-images.githubusercontent.com/67885363/197397021-9cc1cf01-45f9-4488-8c2e-c04169c09a1e.png)

위 테스트 코드에서 이벤트 객체는 2022년 8월 1일로 저장되었다. 
현재 프로덕션 코드에서는 `LocalDate.now`로 조회를 하고 있기 때문에 테스트 돌리는 날짜에 따라 이벤트가 존재하는지 조회하는 날짜가 달라지게 되고 아래의 테스트 코드는 2022년 8월 1일에만 통과하게 된다. 



이 문제를 해결하기 위해 요청 시간을 관리하는 객체를 만들어, 테스트 클래스에서는 가짜 객체를 주입받아 시간을 지정할 수 있게 하고자 하였다. 그리고 출석 시간인지 판단하고, 출석 종료 시간을 계산하는 로직들이 반복되고 있음을 깨닫고 시간에 관련된 비즈니스 로직을 처리하고자 하는 객체를 만들고자 했다.

<br/> 

먼저 LocalDateTime을 필드로 가지는 DateTime이라는 추상 클래스를 만들었다. 
![image](https://user-images.githubusercontent.com/67885363/197398112-3ee581ad-0142-48f0-aa5b-28d14f8ab581.png)



- 프로덕션 코드에서는 ServerDateTime이라는 객체를 사용되게 하고자 했고
![image](https://user-images.githubusercontent.com/67885363/197401384-e441154a-496b-4b08-9379-f439073125e8.png)




- 테스트 코드에서는 FakeDateTime 객체가 사용되게 하고자 했다.
![image](https://user-images.githubusercontent.com/67885363/197398309-1ac7653b-2e04-4e29-90a8-e5126efd049f.png)
그러기 위해서 이 FakeDateTime의 객체 위치를 test 패키지 하위에 배치했고, @Primary 어노테이션이 붙여주었다. 

> 사실 @Primary 어노테이션은 이런 용도로 사용하는 것이 아닐수도 있다.
>
> @Autowired 시에 여러 빈이 매칭될 때 @Primary가 붙은 빈을 우선권을 가지게 하고자 할 때 사용하는 것이다.
>
> 정석적인 방법으로는 @TestConfiguration을 이용해서 테스트 환경을 위한 빈을 정의하는 것이 맞았을수도 있지만, 아래와 같은 방법이 더 편하기도 하고 신기해서 사용했다. 
>
> main과 test 모듈이 달라서 test에 있는 먼저 빈을 읽은건가 싶어서 @Primary를 삭제해보았는데 ServerDateTime 객체가 주입받게 되었고 테스트에 실패하는 것을 확인할 수 있었다. 


<br/> 



그리고 이 DateTime을 필드로 가지고 있고 시간에 관련된 비즈니스 로직을 처리하는 ServerTimeManager라는 객체를 만들었다. 각 서비스 클래스들은 이 클래스를 주입받아 시간에 대한 처리를 하고 있다. 

![image](https://user-images.githubusercontent.com/67885363/197399128-ad71fedd-d312-49b0-9ebb-85ef18b41a93.png)



각 Service 클래스는 빈 스코프를 따로 설정해주지 않기 때문에 싱글톤 스코프다. 

하지만 이 ServerTimeManager의 DateTime은 요청이 들어오는 시간에 따라 (빈을 사용할 때마다) 빈이 새로 생성이 되어야한다. 그래서 빈 스코프를 prototype으로 할지, request로 할 지 고민이 들었는데 request가 더 간편해서 request로 결정하게 되었다.

> 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 주의할 점
>
> 그리고 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 처음 주입받은 프로토타입 빈과 함께 계속 유지된다. (프로토타입 빈은 컨테이너가 빈을 생성하고 초기화할 때까지만 관리하고 종료 시점까지 관리하지 않는다. )
>
> 그래서 프로토타입 빈을 사용할 때마다 ApplicationContext에서 직접 조회하는 로직이 수행되어야 하는데, 이런 것들을 간편하게 해주는 Provider 같은 라이브러리를 사용해야 한다.
>
> 반면 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리한다.