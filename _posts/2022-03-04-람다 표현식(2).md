## 메서드 참조

메서드 참조를 이용하면 기존의 메서드 정의를 재활용하여 람다처럼 전달할 수 있다.

<img width="655" alt="image" src="https://user-images.githubusercontent.com/67885363/156711103-49ce275e-5a4d-47d9-9e5d-8805f6d7476e.png">

```java
inventory.sort((Apple a1, Apple a2) -> 
              a1.getWeight().compareTo(a2.getWeight()));
```

```java
inventory.sort(comparing(Apple::getWeight));
```

메서드 참조는 특정 메서드만을 호출하는 람다의 축약형이다.
메서드를 어떻게 호출하는지 설명하는 것이 아닌 '이 메서드를 직접 호출해'라고 명령하는 느낌이다.
명시적으로 메서드명을 참조함으로써 가독성을 높여줄 수 있다.
메서드명 앞에 `::`를 붙이는 방식으로 메서드 참조를 활용할 수 있다.
**하지만 실제로 메서드를 호출하는 것은 아니다.**
메서드 참조는 람다 표현식을 단지 축약한것으로 괄호는 필요가 없다.
메서드 참조는 새로운 기능이 아니라 하나의 메서드를 참조하는 람다를 편리하게 표현할 수 있는 문법으로 간주할 수 있다.

### 메서드 참조를 만드는 방법

Function<T,R> -> R apply(T t)

Predicate<T> -> boolean test(T t)



- 정적 메서드 참조

```java
    public static int parseInt(String s) throws NumberFormatException {
        return parseInt(s,10);
    }
		
    private List<Integer> toNumbers(List<String> numberValues) {
        return numberValues.stream()
                .map(Integer::parseInt)
                .collect(Collectors.toList());
    }
```



- 다양한 형식의 인스턴스 메서드 참조

```java
    public String trim() {
        String ret = isLatin1() ? StringLatin1.trim(value)
                                : StringUTF16.trim(value);
        return ret == null ? this : ret;
    }

    private List<String> toStrings(String stringArray) {
        return Arrays.stream(stringArray.split(DELIMITER))
                .map(String::trim)
                .collect(Collectors.toList());
    }
```



- 기존 객체의 인스턴스 메서드 참조

```java
    public boolean isContainLottoNumber(LottoNumber lottoNumber) {
        return winningLotto.isContainLottoNumber(lottoNumber);
    }

    public Result judge(WinningLotto winningLotto) {
        int hitCount = (int) lotto.stream()
                .filter(winningLotto::isContainLottoNumber)
                .count();
      ...
    }
```

비공개 헬퍼 메서드를 정의한 상황에서 유용하게 활용할 수 있다.

> 헬퍼 클래스란?
>
>  helper class는 일부 기능을 제공하여 도와주지만, 에플리케이션이나 클래스의 주목적으로는 사용될 수 없다고 한다. 
> 정리하면 helper class는 보조적인 역할로 사용되며, 꼭 필요하지는 않다고 할 수 있다.
> 하지만 조금 달리 보면 utility class와 helper class는 비슷하다고 생각할 수도 있습니다. utility class도 보조적인 역할로 사용되는데 말이죠.
>
> 하지만 utility class는 모든 메소드가 정적 메소드입니다.
> 일반적으로 helper class는 모든 메소드가 정적 메소드이지 않으며, 여러 개의 helper class의 인스턴스가 있을 수 있습니다.
>
> 또한, helper class는 private로 선언하여 다른 곳에서의 접근을 막도록 하는 것이 좋습니다. 
> 이는 특정 클래스를 도와주기 위해 helper class를 만든 것이지, 외부에서 접근하여 사용할 목적으로 만든 것이 아니기 때문입니다. 그리고 다른 helper class와 의존성이 생기지 않도록 해야 합니다.



컴파일러는 람다 표현식의 형식을 검사하던 방식과 비슷한 과정으로 메서드 참조가 주어진 함수형 인터페이스와 호환하는지 확인한다.
즉, 메서드 참조는 컨텍스트의 형식과 일치해야 한다.

<br/>

### 생성자 참조

`ClassName::new`처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.
이것은 정적 메서드의 참조를 만드는 방법과 비슷하다.

- 인수가 없는 생성자

```java
    Supplier<Car> carGenerator = Car::new;
    Supplier<Car> carSupplier = () -> new Car();

    public static List<Car> createCarList(Supplier<Car> carGenerator, int numberOfCar) {
        List<Car> carList = new ArrayList<>();

        for (int i = 0; i < numberOfCar; i++) {
            carList.add(carGenerator.get());
        }
        return carList;
    }
```

- 인수가 있는 생성자

<img width="566" alt="image" src="https://user-images.githubusercontent.com/67885363/156728302-137292d7-52ad-4f0c-9020-544e4829610a.png">

```java
    Function<String, Car> carGenerator = Car::new;
    Function<String, Car> carGenerator2 = name -> new Car(name);

    public static List<Car> from(String names) {
        String[] arrNames = names.split(",");
        return Arrays.stream(arrNames)
                .map(String::trim)
                .map(Car::new)
                .collect(Collectors.toList());
    }
```

<br/>



## 람다, 메서드 참조 활용하기

자바 8의 List API의 sort를 이용해 사과 리스트를 정렬을 할 것인데, 객체들은 이 때 정렬 전략이 필요하다.

```java
void sort(Comparator<? super E> c)
```

Comparator 객체를 인수로 받아 두 사과를 비교한다.
객체 안에 동작을 포함시키는 방식으로 다양한 전략을 전달할 수 있는데 sort의 동작은 파라미터화된다라고 말할 수 있다.

**1단계 : 코드 전달**

```java
public class AppleComparator implements Comparator<Apple> { 
  public int compare(Apple a1, Apple a2) { 
    return a1.getWeight().compareTo(a2.getWeight()); 
  } 
} 

inventory.sort(new AppleComparator());
```



**2단계 : 익명 클래스 사용**

```java
inventory.sort(new Comparator<Apple>() { 
  public int compare(Apple a1, Apple a2) { 
    return a1.getWeight().compareTo(a2.getWeight()); 
  } 
}
```



**3단계 : 람다 표현식 사용**

Comparator의 함수 디스크립터(T, T) -> int를 사용해 람다 표현식으로 작성할 수 있다.

```java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

// 람다 표현식이 사용된 컨텍스트를 활용해 파라미터 형식을 추론하므로 한번 더 줄일 수 있다.
inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight()));
```



Comparator는 Comparable 키를 추출해서 Comparator 객체로 만드는 Function 함수를 인수로 받는 정적 메서드 comparing을 포함한다.

```java
Comparator<Apple> c = Comparator.comparing((apple a) -> a.getWeight());

inventory.sort(comparing(apple -> apple.getWeight());
```



**4단계 : 메서드 참조**

```java
inventory.sort(comparing(Apple::getWeight));
```

코드의 의미도 더 명확해졌다.
코드 자체로 Apple을 weight 별로 비교해서 inventory를 sort 하라는 의미를 전달할 수 있다.

<br/>



## 람다 표현식을 조합할 수 있는 유용한 메서드

여러 개의 람다 표현식을 조합해 복잡한 람다 표현식을 만들 수 있다.
함수형 인터페이스가 제공하는 디폴트 메서드를 사용하면, 두 연산을 수행하거나 함수의 결과가 다른 함수의 입력이 되도록 조합할 수도 있다.

### Comparator 조합

**역정렬**

```java
inventory.sort(comparing(Apple::getWeight).reversed());
```



**Comparator 연결**

```java
inventory.sort(comparing(Apple::getWeight) 
               .reversed() 
               .thenComparing(Apple::getCountry));
```

thenComparing은 함수로 인수로 받아 첫 번째 비교자에서 같다고 판단된 객체를 처리한다.



### Predicate 조합

Predicate 인터페이스는 복잡한 프레디케이트를 만들 수 있도록 negate, and, or 세가지 메서드를 제공한다.

- 빨간 색이 아닌 사과 처럼 특정 프레디케이트를 반전시킬 때 `negate` 메서드를 사용할 수 있다.

```java
Predicate<Apple> notRedApple = redApple.negate();
```



- `and` 메서드를 이용해 빨간색이면서 무거운 사과를 선택하도록 람다를 조합할 수도 있다.

```java
Predicate<Apple> RedHeavyApple = redApple.and(apple -> apple.getWeight > 150);
```



- `or` 메서드를 이용해서 빨간색이면서 무거운 사과 또는 그냥 녹색사과 등의 조건을 만들 수 있다.

```java
Predicate<Apple> RedHeavyOrGreenApple = 
  redApple.and(apple -> apple.getWeight > 150) 
  				.or(apple -> GREEN.equals(a.getColor()));
```



### Function 조합

Function 인터페이스는 Function 인터페이스를 반환하는 andThen, compose 두 가지 디폴트 메서드를 제공한다.

- `andThen` 메서드는 주어진 함수를 먼저 적용한 결과를 다른 함수의 입력으로 전달하는 함수를 반환한다.

```java
Function<Integer, Integer> f = x -> x + 1; 
Function<Integer, Integer> g = x -> x * 2; 
Function<Integer, Integer> h = f.andThen(g); //g(f(x))

int result = h.apply(1); // 4를 반환
```



- compose 메서드는 인수로 주어진 함수를 먼저 실행한 다음 그 결과를 외부 함수의 인수로 제공한다.

```java
Function<Integer, Integer> f = x -> x + 1; 
Function<Integer, Integer> g = x -> x * 2; 
Function<Integer, Integer> h = f.compose(g); //f(g(x)) 

int result = h.apply(1); // 3을 반환
```



여러 유틸리티 메서드를 조합해 다양한 변환 파이프라인을 만들 수 있다.
헤더를 추가한 다음, 철자 검사를 하고, 마지막에 푸터를 추가하는 예이다.

```java
Function<String, String> addHeader = Letter::addHeader; 
Function<String, String> transFormationPipeline = 
  addHeader .andThen(Letter::checkSpelling) 
            .andThen(Letter::addFooter);
```

