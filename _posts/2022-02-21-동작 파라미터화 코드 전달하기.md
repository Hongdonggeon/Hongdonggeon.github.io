---
title: 동작 파라미터화 코드 전달하기
toc: true
toc_sticky: true
categories:
  - java
date: 2022-02-21
---

## 동작 파라미터화 코드 전달하기

소비자 요구사항은 항상 바뀌고, 변화하는 요구 사항은 소프트웨어 엔지니어링에서 피할 수 없는 문제다.
그러면 시시각각 변하는 사용자 요구 사항에 어떻게 대응해야 할까?
엔지니어링적인 비용이 가장 최소화 될 수 있어야 하고, 유지보수가 쉬워야 한다.

동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.
동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다.
즉, 코드 블록의 실행은 나중으로 미뤄진다.

ex) 친구는 슈머파켓에 갔다가 집으로 돌아오는 길을 알고 있다. 그래서 친구에게 음식좀 사오라고 부탁을 했다.
이 동작은 goAndBuy라는 메서드를 호출하면서 사려는 물품을 파라미터로 전달하는 것으로 비유 할 수 있다.
그런데 어느날 , 친구에게 우체국에서 소포를 받아와 달라고 부탁해야 하는데, 친구는 소포를 가져온 경험이 없다.
그래서 나는 친구에게 우체국에서 소포를 가져오는 방법을 상세하게 정리해서 알려줘야 한다. 
이 상황을 비유 했을 때, 소포를 가져오는 동작을 메서드의 파라미터로 전달하는 것이다.



## 요구 사항에 따라 대응하기

- 첫번째 요구 사항 : 녹색 사과 필터링 해주세요
- 첫번째 시도 : 녹색 사과 필터링

```java
    public static List<Apple> filterGreenApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (apple.getColor() == Color.GREEN) {
                result.add(apple);
            }
        }
        return result;
    }
```



- 두번째 요구 사항 : 빨간 사과 필터링 해주세요 + 무게에 따라 사과를 필터링 해주세요
- 두번째 시도 : 색을 파라미터화 + 무게에 따라 필터링 하는 메서드 추가

```java
    public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (apple.getColor() == color) {
                result.add(apple);
            }
        }
        return result;
    }

```



```java
    public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (apple.getWeight() > weight) {
                result.add(apple);
            }
        }
        return result;
    }
```

좋은 해결책이었지만, 색 필터링 코드와 무게 필터링 코드 거의 중복
소프트웨어 공학의 DRY(don't repeat yourself) 원칙을 어기고 있다.



- 세번째 시도 : 가능한 모든 속성으로 필터링 (어떤 것을 기준으로 필터링할지 flag 사용)

```java
    public static List<Apple> filterApplesByWeight(List<Apple> inventory, Color color, int weight, boolean flag) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if ((flag && apple.getColor().equals(color)) || (!flag && apple.getWeight() > weight)) {
                result.add(apple);
            }
        }
        return result;
    }
```

형편없는 코드. 파라미터가 무엇을 뜻하는지 불분명하다.
그리고 요구사항이 또 바뀌면 유연하게 대응도 불가능하다.



### 동작 파라미터화

요구사항에 유연하게 대응하기 위해 필터링 조건에 따라 불리언 값을 반환하는 방식을 생각해보자.
참 또는 거짓을 반환하는 함수를 **프레디케이트**라고 한다.

```java
// 알고리즘 패밀리
public class ApplePredicate {
    boolean test(Apple apple);
}
```



```java
// 전략 1
public class AppleHeavyWeightPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return apple.getWeight() > 150;
    }
}

// 전략 2
public class AppleGreenColorPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return apple.getColor() == Color.GREEN;
    }
}
```

위 조건에 따라 filter 메서드가 다르게 동작할 것이라고 예상할 수 있다. 이를 전략 디자인 패턴이라고 한다.
전략 디자인 패턴은 각 전략들을 캡슐화하는 알고리즘 패밀리를 정의해둔 다음 런타임에 선택하는 기법이다.

filterApples에서 AppliePredicate 객체를 받아 애플의 조건을 검사하도록 메서드를 고쳐야 한다.
이렇게 동작 파라미터화, 즉 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작을 수행할 수 있다.



- 네번째 시도 : 추상적 조건으로 필터링

filter 메서드
```java
    public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (p.test(apple)) {
                result.add(apple);
            }
        }
        return result;
    }
```


무겁고 빨간 사과를 필터링하는 전략

```java
public class AppleRedHeavyWeightPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return RED.equals(apple.getColor()) && apple.getWeight() > 150;
    }
}
```



우리가 전달한 ApplePredicate 객체에 의해 filterApples 메서드의 동작이 결정되는 것이다.
즉, 우리는 filterApples 메서드의 동작을 파라미터화한 것이다.
가장 중요한 구현은 test 메서드이고, 메서드는 객체만 인수로 받으므로 test 메서드를 ApplePredicate 객체로 감싸서 전달해야 한다.



## 복잡 한 과정 간소화

### 익명 클래스

자바는 클래스의 선언과 인스턴스화를 동시에 수행할 수 있도록 익명 클래스라는 기법을 제공한다.
익명 클래스는 말 그대로 이름이 없는 클래스다. 익명 클래스를 이용하면 클래스 선언과 인스턴스화를 동시에 할 수 있다.

- 5번째 시도 : 익명 클래스 사용

```java
    List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
        public boolean test(Apple a) {
            return RED.equals(apple.getColor());
        }
    });
```

익명 클래스도 여전히 많은 공간 차지한다.
장황한 코드는 유지보수하는데 오래걸릴 뿐 아니라, 즐거움을 빼앗는다.



- 여섯번째 시도 : 람다 표현식 사용

```java
    List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```

이전 코드보다 훨씬 간단해졌다.



## 실전 예제

### Comparator로 정렬하기

정렬 기준 요구사항이 계속 바뀔 때, 우리는 어떻게 정렬해야 하는가?
Comparator를 구현해서 sort 메서드의 동작을 다양화할 수 있다.

- 익명 클래스 사용

```java
    inventory.sort(new Comparator<Apple>()
    {
        public int compare (Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
    });
```

- 람다 사용

```java
		inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
```



### Runnable로 코드 블록 실행하기

자바 스레드를 이용하면 병렬로 코드 블록을 실행할 수 있다.
자바 8까지는 Thread 생성자에 객체만을 전달할 수 있었으므로 보통 결과를 반환하지 않는 void run 메서드를 포함하는 익명 클래스가 Runnable 인터페이스를 구현하도록 하는 것이 일반적인 방법이다.

```java
		public interface Runnable {
   	 	void run();
		}

    Thread t = new Thread(new Runnable() {
        public void run() {
            System.out.println("hello world");
        }
    });
```

- 8부터는 람다 사용

```java
		Thread t = new Thread(() -> System.out.println("Hello world"));
```



### Callable을 결과로 반환하기

ExecutorService 인터페이스를 이용하면 태스크를 스레드 풀로 보내고 결과를 Future로 저장할 수 있다.

```java
Future<String> threadName = executorService.submit(() -> Thread.currentThread().getName())
```

f

