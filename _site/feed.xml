<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-16T02:49:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Keep Going</title><author><name>kun</name></author><entry><title type="html">2022.02.15 인스턴스 메서드 vs 클래스 메서드</title><link href="http://localhost:4000/java/til/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C-vs-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C/" rel="alternate" type="text/html" title="2022.02.15 인스턴스 메서드 vs 클래스 메서드" /><published>2022-02-15T00:00:00+09:00</published><updated>2022-02-15T00:00:00+09:00</updated><id>http://localhost:4000/java/til/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%20%EB%A9%94%EC%84%9C%EB%93%9C%20vs%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A9%94%EC%84%9C%EB%93%9C</id><content type="html" xml:base="http://localhost:4000/java/til/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C-vs-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C/"><![CDATA[<h2 id="static-메서드는-언제-사용해야-하나">static 메서드는 언제 사용해야 하나?</h2>

<p>평소에 static 메서드의 사용 여부에 대해 많이 고민이 되는 것 같다.
자동차 경주 게임 미션을 하면서도, 고민이 되는 경우가 있었다.
일단, 게임에 있어서 판정을 해주는 Referee 클래스 이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Referee</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MOVE_CRITERIA</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canCarMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">randomValue</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">randomValue</span> <span class="o">&gt;=</span> <span class="no">MOVE_CRITERIA</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;</span> <span class="nf">judgeWinner</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;</span> <span class="n">cars</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxPosition</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">cars</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
			<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">car</span> <span class="o">-&gt;</span> <span class="n">car</span><span class="o">.</span><span class="na">isPosition</span><span class="o">(</span><span class="n">maxPosition</span><span class="o">))</span>
			<span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>고민 끝에, Referee 클래스는 유틸리티 클래스로 설계하였다.
그때, 유틸리티 클래스 설계로 결정한 이유로는 여러가지가 있다.</p>

<ul>
  <li>여러 개의 객체가 필요가 없다는 점</li>
  <li>인스턴스 필드가 없다는 점</li>
</ul>

<p>이때만 해도, 인스턴스 필드가 인스턴스의 상태 정보를 나타내는지는 몰랐다.
인스턴스 필드를 상태 변수라고도 이야기 한다고 한다.
무조건적이진 않겠지만, 인스턴스화 할 클래스로 만들 것인지, 유틸리티 클래스로 만들 것인지 고민이 된다면, 인스턴스 필드의 여부를 생각해보면 될 것 같다.</p>

<p>다시 생각해봤을 때, Referee 클래스는 아무런 상태 변수도 없기 때문에 유틸리티 클래스로 만들어 주길 잘한 것 같다.</p>

<p><br /></p>

<p>두번재는, 모든 로직에 대해서 조립을 해주는 Game 클래스다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Game</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">WINNER_NAME_DELIMITER</span> <span class="o">=</span> <span class="s">", "</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">NEGATIVE_ERROR_MESSAGE</span> <span class="o">=</span> <span class="s">"[ERROR] 음수를 입력할 수 없습니다"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">ERROR_CRITERIA_VALUE_ZERO</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Cars</span> <span class="n">cars</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cars</span><span class="o">(</span><span class="nc">CarFactory</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nc">InputView</span><span class="o">.</span><span class="na">inputCarNames</span><span class="o">()));</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;</span> <span class="n">carSet</span> <span class="o">=</span> <span class="n">cars</span><span class="o">.</span><span class="na">getCars</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">validateGameCount</span><span class="o">(</span><span class="nc">InputView</span><span class="o">.</span><span class="na">inputGameCount</span><span class="o">());</span>
        <span class="nc">OutputView</span><span class="o">.</span><span class="na">printGameResultTitle</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">play</span><span class="o">(</span><span class="n">carSet</span><span class="o">);</span>
            <span class="n">showResult</span><span class="o">(</span><span class="n">carSet</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">showWinner</span><span class="o">(</span><span class="nc">Referee</span><span class="o">.</span><span class="na">judgeWinner</span><span class="o">(</span><span class="n">carSet</span><span class="o">,</span> <span class="n">cars</span><span class="o">.</span><span class="na">getMaxPosition</span><span class="o">()));</span>
    <span class="o">}</span>
  
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Car</span> <span class="n">car</span> <span class="o">:</span> <span class="n">cars</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">canCarMove</span> <span class="o">=</span> <span class="nc">Referee</span><span class="o">.</span><span class="na">canCarMove</span><span class="o">(</span><span class="n">makeRandomValue</span><span class="o">());</span>
            <span class="n">car</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">canCarMove</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
  
  <span class="o">....</span>
</code></pre></div></div>

<p>지금 다시 보니, 애매한 것 같다.
인스턴스 필드는 없는데, 메서드들은 다 인스턴스 메서드로 선언이 되어 있다.
모든 메서드를 static 메서드로 바꾸면, 유틸리티 클래스가 될 것 같은데,,,,
무언가 모든 메서드를 static 메서드를 만들기엔 부담스럽다는 생각이 든다.</p>

<p>그리고, 이 Game 클래스의 <code class="language-plaintext highlighter-rouge">play()</code>는 상태를 Car들의 position값을 변하게 해준다,
즉, 객체의 상태를 변화시켜준다.</p>

<p>Car들을 관리해주는 Cars를 인스턴스 필드로 사용해서 리팩토링 해봐야겠다.</p>

<p><br /></p>

<h2 id="인스턴스-메서드">인스턴스 메서드</h2>

<p>인스턴스의 상태를 변경하거나 상태 정보를 반환할 때 사용하는 메소드다.
인스턴스를 생성한 후, 메세지를 보낼 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">canCarMove</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">canCarMove</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">position</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="클래스-메서드">클래스 메서드</h2>

<p>인스턴스의 상태와는 관련이 없다.
인스턴스를 생성하지 않은 상태에서도 호출이 가능하다.
클래스 메서드는 유틸리티 메서드라고 부른다.
static이 붙은 변수나 메서드들은 JVM이 시작될 때, static 영역에 저장되고 프로그램이 끝날 때까지 사라지지 않고 메모리에 남아있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="nc">String</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arrNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
        <span class="k">return</span>  <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arrNames</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">trim</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Car:</span><span class="o">:</span><span class="k">new</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="static-메서드의-장단점">static 메서드의 장단점</h2>

<h3 id="속도가-빨라지고-반복적인-사용에-효율적이다">속도가 빨라지고 반복적인 사용에 효율적이다.</h3>

<p>메서드를 사용할 때, 객체를 생성해 줄 필요가 없으니 생성자를 호출할 필요가 없게 되고 속도가 빨라질 수밖에 없다.</p>

<p><br /></p>

<h3 id="객체-지향에서-멀어진다">객체 지향에서 멀어진다.</h3>

<p>static 메서드는 객체의 생명 주기와 관계없이 프로그램 시작부터 끝날 때까지 메모리에 남아있기 때문에 객체 지향이라는 키워드와는 멀어진다.
객체 지향에서는, 객체들은 서로 관계를 맺고 메시지를 통해 정보를 교환하고 반환한다.
정적 메서드는 객체에게 행위를 지시하는 것이 아닌 함수 호출에 불과하다.
그리고 정적 메서드는 오버라이딩이 불가하므로 인터페이스에서는 사용할 수도 없게 된다.
정적 메서드는 런타임 이전 컴파일시에 정적 바인딩이 이루어지기 때문에, 동적 바인딩도 불가능하다.</p>

<p><br /></p>

<h3 id="메모리-효율이-떨어질-수-있다">메모리 효율이 떨어질 수 있다.</h3>

<p>런타임 중 동적으로 생성된 것들은 가비지 컬렉션의 대상이 되는데, 정적으로 할당된 static 영역은 대상이 아니다.
static으로 할당된 영역이 커지면 가비지 컬렉션의 효율이 떨어지게 된다.
static 영역은 프로그램이 끝날 때까지 메모리에서 내릴 수 없게 되므로 효율이 떨어질 수 있다.</p>

<p><br />
 <br /></p>

<hr />

<p>참고 <a href="https://tecoble.techcourse.co.kr/post/2020-07-16-static-method/">https://tecoble.techcourse.co.kr/post/2020-07-16-static-method/</a></p>]]></content><author><name>kun</name></author><category term="java" /><category term="til" /><summary type="html"><![CDATA[static 메서드는 언제 사용해야 하나?]]></summary></entry><entry><title type="html">Java 8에서는 무슨일이 일어났는가?</title><link href="http://localhost:4000/java/%EC%9E%90%EB%B0%94-8%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%AC%EB%8A%94%EA%B0%80/" rel="alternate" type="text/html" title="Java 8에서는 무슨일이 일어났는가?" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/java/%EC%9E%90%EB%B0%94%208%EC%97%90%EC%84%9C%EB%8A%94%20%EB%AC%B4%EC%8A%A8%EC%9D%BC%EC%9D%B4%20%EC%9D%BC%EC%96%B4%EB%82%AC%EB%8A%94%EA%B0%80</id><content type="html" xml:base="http://localhost:4000/java/%EC%9E%90%EB%B0%94-8%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%AC%EB%8A%94%EA%B0%80/"><![CDATA[<h1 id="자바-8-9-10-11-무슨일이-일어나고-있는가">자바 8, 9, 10, 11 무슨일이 일어나고 있는가</h1>

<p>자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.<br /></p>

<p>자바 8이 등장하기 이전의 자바 프로그램은 코어 중 하나만을 사용했다.<br />그래서 나머지 코어를 활용하려면 스레드를 사용하는 것이 좋다는 말이 있었다.<br />하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다.<br />자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.<br /></p>

<p><strong>자바 8의 새로운 기술</strong></p>

<ul>
  <li>스트림 API -&gt; 병렬 연산 지원 (synchronized 키워드를 사용하지 않아도 된다.)</li>
  <li>메서드에 코드를 전달하는 기법 -&gt; 동작 파라미터 구현 가능, 함수형 프로그래밍에서 많이 사용된다.</li>
  <li>인터페이스의 디폴트 메서드 -&gt; 인터페이스의 구현체 클래스들을 다 수정하지 않아도 된다.</li>
</ul>

<p><br /></p>

<h2 id="자바-함수">자바 함수</h2>

<p>프로그래밍 언어에서 함수라는 용어는 메서드, 특히 정적 메서드와 같은 의미로 사용된다.<br />자바 8에서는 함수를 새로운 값의 형식으로 추가했다.<br />이는 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문이다.</p>

<ul>
  <li>자바 프로그램에서의 조작할 수 있는 값 -&gt; primitive type과 객체의 값<br />ex) 42(int), “abc”(String), new HashMap()&lt;Integer, String&gt;</li>
</ul>

<p><strong>프로그래밍 언어의 핵심은 값을 바꾸는 것이다.</strong><br />전통적으로 프로그래밍 언어에서는 조작할 수 있는 값을 일급값 또는 일급시민이라고 부른다.</p>

<p>또는 다양한 구조체(메서드, 클래스)가 값의 구조를 표현하는데 도움이 될 수 있다.<br />하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다.<br />이렇게 전달할 수 없는 구조체는 이급 시민이다. ex) 메서드, 클래스 -&gt; 그 자체로 값이 될 수 없다.</p>

<p>메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다. (자바8에서 이급 시민을 일급 시민으로 바꿀 수 있는 기능 추가)</p>

<p><br /></p>

<h3 id="메서드와-람다를-일급-시민으로">메서드와 람다를 일급 시민으로</h3>

<p><strong>메서드 참조</strong></p>

<ul>
  <li>메서드 참조 사용하기 전</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">File</span><span class="o">[]</span> <span class="n">hiddenFiles</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">","</span><span class="o">).</span><span class="na">listFiles</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileFilter</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">File</span> <span class="n">pathname</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">pathname</span><span class="o">.</span><span class="na">isHidden</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">});</span>
</code></pre></div></div>

<p>File 클래스에는 이미 isHidden이라는 메서드가 있는데 왜 굳이 FileFileter로 감싼 다음에 FileFilter를 인스턴스화해야 하나?</p>

<ul>
  <li>메서드 참조 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nc">File</span><span class="o">[]</span> <span class="n">hiddenFiles2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"."</span><span class="o">).</span><span class="na">listFiles</span><span class="o">(</span><span class="nl">File:</span><span class="o">:</span><span class="n">isHidden</span><span class="o">);</span>
</code></pre></div></div>

<p>isHidden이라는 메서드가 File 클래스에 준비되어 있으므로 메서드 참조를 이용해서 listFiles에 직접 전달하였다.<br /></p>

<p><code class="language-plaintext highlighter-rouge">::</code>  : 메서드를 값으로 사용해라</p>

<p><br /></p>

<p><strong>람다 : 익명함수</strong></p>

<p>메서드를 일급값으로 취급할 뿐 아니라 람다(또는 익명함수)를 포함하여 함수도 값으로 취급할 수 있다.<br />직접 메서드를 정의해서 메서드 참조를 이용할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결한 코드를 작성할 수 있다.<br /></p>

<p><strong>람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 함수를 일급값으로 넘겨주는 프로그램을 구현한다.</strong></p>

<p><br /></p>

<p><strong>예시</strong></p>

<p>Apple 클래스가 존재하고 Apple 객체의 무게를 반환해주는 getWeight() 이라는 메서드가 존재한다.<br />Apple 타입의 리스트에서 무게가 150보다 큰 Apple 객체들을 필터링하는 작업을 해볼 것이다.</p>

<ul>
  <li>메서드를 전달하지 않은 코드</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="nf">filterHeavyApples</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="n">inventory</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Applie</span> <span class="n">apple</span> <span class="o">:</span> <span class="n">inventory</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">apple</span><span class="o">.</span><span class="na">getWeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">150</span><span class="o">)</span> <span class="o">{</span>
                  <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">apple</span><span class="o">);</span>
               <span class="o">}</span>
            <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>단점 : 다른 기준으로 필터링하는 코드를 작성할 때, 거의 동일한 코드가 여러번 반복된다.<br /></p>

<ul>
  <li>메서드를 전달하는 코드</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="nf">filterApples</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="n">inventory</span><span class="o">,</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
          <span class="k">for</span> <span class="o">(</span><span class="nc">Apple</span> <span class="n">apple</span> <span class="o">:</span> <span class="n">inventory</span><span class="o">){</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">apple</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">apple</span><span class="o">);</span>
                <span class="o">}</span>
              <span class="o">}</span>
    <span class="o">}</span> 

<span class="c1">// 사용할 때</span>
	<span class="n">filterApples</span><span class="o">(</span><span class="n">inventory</span><span class="o">,</span> <span class="nl">Apple:</span><span class="o">:</span><span class="n">isGreenApple</span><span class="o">);</span>
	<span class="n">filterApples</span><span class="o">(</span><span class="n">inventory</span><span class="o">,</span> <span class="nl">APPLE:</span><span class="o">:</span><span class="n">isHeavyApple</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="메서드-전달에서-람다로">메서드 전달에서 람다로</h3>

<p>메서드를 값으로 전달하는 것은 분명 유용한 기능이다.<br />하지만 한 두번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다.<br />자바 8에서는 람다를 사용해서 코드를 구현할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">filterApples</span><span class="o">(</span><span class="n">inventory</span><span class="o">,</span> <span class="o">(</span><span class="nc">Apple</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">getWeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">150</span><span class="o">);</span>
	<span class="n">filterApples</span><span class="o">(</span><span class="n">inventory</span><span class="o">,</span> <span class="o">(</span><span class="nc">Apple</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">GREEN</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">getColor</span><span class="o">()));</span>
</code></pre></div></div>

<p>한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없지만 람다가 몇 줄 이상으로 길어진다면 익명 람다 보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다.<br />코드의 명확성이 우선시되어야 한다.</p>

<p>위에서 filterApples라는 새로운 메서드를 정의하였는데, 라이브러리 메서드 filter를 사용하면 메서드를 구현할 필요가 없다.<br />자바 8에서는 filter와 비슷한 동작을 수행하는 연산집합을 포함하는 새로운 스트림 API를 제공한다.</p>

<p><br /><br /></p>

<h2 id="스트림">스트림</h2>

<p>거의 모든 자바 어플리케이션은 컬렉션을 만들고 활용한다.<br />스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다.</p>

<ul>
  <li>컬렉션
    <ul>
      <li>반복 과정 직접 처리 (외부 반복)</li>
    </ul>
  </li>
  <li>스트림 API
    <ul>
      <li>라이브러리 내부에서 모든 데이터 처리 (내부 반복)</li>
    </ul>
  </li>
</ul>

<p>많은 요소를 가진 목록을 반복한다면 오랜 시간이 걸릴 수 있다.<br />단일 cpu로는 거대한 데이터를 처리하기 힘들다. 하지만 우리는 현재 대부분 멀티 코어 cpu를 사용한다.<br />따라서 서로 다른 cpu 코어에 작업을 각각 할당해서 처리 시간을 줄일 수 있다면 좋다.</p>

<p><br /></p>

<h3 id="멀티스레딩은-어렵다">멀티스레딩은 어렵다</h3>

<p>스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다.<br />멀티 스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있는데 스레드를 잘 제어하지 못하면 원치 않은 방식으로 바뀐다.</p>

<p>하지만 자바 8에서 부터 스트림 API로 ‘컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’, ‘멀티코어 활용 어려움’ 이라는 2가지 문제를 모두 해결했다.<br />기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 너무 많았는데, 라이브러리에서 이러한 반복되는 패턴을 제공한다면 좋을 것이라는 아이디어가 변화의 동기가 되었다.<br />자주 반복되는 패턴으로 데이터를 필터링, 추출, 그룹화 등의 기능이 있다.<br />또한 이러한 동작들을 쉽게 병렬화할 수 있다는 점도 변화의 동기가 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/153752496-cf7a56fc-7077-4ea3-b419-69c49560a7cf.png" alt="image" /></p>

<ul>
  <li>포킹 단계<br />두 cpu를 가진 환경에서 리스트를 필터링할 때 한 cpu는 리스트의 앞부분을 처리하고, 다른 cpu는 리스트의 뒷부분을 처리하도록 요청할 수 있다.</li>
  <li>각각의 cpu는 자신이 맡은 절반의 리스트를 처리한다.</li>
  <li>마지막으로 하나의 cpu가 두 결과를 정리한다.</li>
</ul>

<p><strong>컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두고, 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다.</strong></p>

<p>스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Apple</span><span class="o">&gt;</span> <span class="n">heavyApples</span> <span class="o">=</span> <span class="n">inventory</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
                                   <span class="o">.</span><span class="na">filter</span><span class="o">(</span> <span class="o">(</span><span class="nc">Apple</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">getWeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">150</span><span class="o">)</span>
                                   <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
</code></pre></div></div>

<p><br /><br /></p>

<h2 id="디폴트-메서드와-자바-모듈">디폴트 메서드와 자바 모듈</h2>

<p>요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다.<br />지금까지 자바에서는 특별한 구조가 아닌 평범한 자바 패키지 집합을 포함하는 JAR파일을 제공하는 것이 전부였다.<br />게다가 패키지의 인터페이스를 바꿔야 하는 상황에서는 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 했으므로 정말 고통스러운 작업이었다.</p>

<p>자바8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.<br />디폴트 메서드는 특정 프로그램을 구현하는데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다.</p>

<p>현재 Collection 인터페이스에는 stream이라는 메서드가 정의되지 않았다고 가정하자.<br />List의 스트림이 사용된 코드를 컴파일 되게 하기 위해서는 직접 Collection 인터페이스에 stream 메서드를 추가하고 ArrayList 클래스에서 메서드를 구현해야 한다.<br />하지만 이미 컬렉션 API의 인터페이스를 구현하는 많은 컬렉션 프레임워크가 존재하는데 인터페이스를 구현한 모든 클래스는 새로 추가된 메서드를 구현해야 한다.<br />현실적으로 언어 설계자들이 인터페이스에 구현한 모든 코드를 책임질 수 없기에, 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다.<br />이러한 메서드를 디폴트 메서드라고 부르고 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">default</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>]]></content><author><name>kun</name></author><category term="java" /><summary type="html"><![CDATA[자바 8, 9, 10, 11 무슨일이 일어나고 있는가]]></summary></entry><entry><title type="html">2022.02.13 함수 vs 메서드 , TDA 법칙, 커밋에는 어떤 내용이</title><link href="http://localhost:4000/java/til/%ED%95%A8%EC%88%98-vs-%EB%A9%94%EC%84%9C%EB%93%9C/" rel="alternate" type="text/html" title="2022.02.13 함수 vs 메서드 , TDA 법칙, 커밋에는 어떤 내용이" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/java/til/%ED%95%A8%EC%88%98%20vs%20%EB%A9%94%EC%84%9C%EB%93%9C</id><content type="html" xml:base="http://localhost:4000/java/til/%ED%95%A8%EC%88%98-vs-%EB%A9%94%EC%84%9C%EB%93%9C/"><![CDATA[<h2 id="함수-vs-메서드">함수 vs 메서드</h2>
<p>모던 자바 인 액션을 읽는 중, 책에서 설명을 할 때 메서드와 함수를 다른 의미로 사용하는 듯 했다.<br />
함수와 메서드는 같은 의미지 않나라는 생각이 들었고, java 공부를 시작하면서 함수라는 단어는 사용을 잘 안 한듯한 느낌이 들었다.<br />
함수와 메서드의 용어에 대해서 생각해보게 되었다.
<br /></p>

<h3 id="함수">함수</h3>
<p>프로그래밍 언어에 있어서 함수라는 것은 어떠한 기능을 수행하는 것이다.
<br /></p>

<h3 id="메서드">메서드</h3>
<p>메서드도 함수처럼 어떠한 기능을 수행하는 것인데, 차이가 있다면 메서드는 클래스와 연관되어 있는 함수라는 것이다.<br /> 
 클래스 내에 선언되어 있는 함수가 바로 메서드다. 
 <br /></p>

<h3 id="정리">정리</h3>

<p><strong>클래스 및 객체와 연관되어 있는 것이라면 메서드고, 그것들과 상관없이 독립적으로 존재하는 것은 함수다. 함수가 메서드보다 더 큰 개념이라고 생각할 수 있다.</strong>
 Java 클래스에서 함수라는 용어를 사용하지 않았던 것은, Java는 모두 클래스로 이루어져있고 클래스 밖에 어떠한 것도 선언할 수 없기 때문이었다.</p>

<p><br />
<br /></p>

<h2 id="tdatell-dont-ask-법칙">TDA(Tell don’t ask) 법칙</h2>

<p><br />
<br /></p>

<h2 id="커밋">커밋</h2>]]></content><author><name>kun</name></author><category term="java" /><category term="til" /><summary type="html"><![CDATA[함수 vs 메서드 모던 자바 인 액션을 읽는 중, 책에서 설명을 할 때 메서드와 함수를 다른 의미로 사용하는 듯 했다. 함수와 메서드는 같은 의미지 않나라는 생각이 들었고, java 공부를 시작하면서 함수라는 단어는 사용을 잘 안 한듯한 느낌이 들었다. 함수와 메서드의 용어에 대해서 생각해보게 되었다.]]></summary></entry><entry><title type="html">2022.02.11 스트림 joining, 상대방 커밋 이력 가져오기</title><link href="http://localhost:4000/til/java/%EC%8A%A4%ED%8A%B8%EB%A6%BC-joining,-%EC%83%81%EB%8C%80%EB%B0%A9-%EC%BB%A4%EB%B0%8B-%EC%9D%B4%EB%A0%A5-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/" rel="alternate" type="text/html" title="2022.02.11 스트림 joining, 상대방 커밋 이력 가져오기" /><published>2022-02-11T00:00:00+09:00</published><updated>2022-02-11T00:00:00+09:00</updated><id>http://localhost:4000/til/java/%EC%8A%A4%ED%8A%B8%EB%A6%BC%20joining,%20%EC%83%81%EB%8C%80%EB%B0%A9%20%EC%BB%A4%EB%B0%8B%20%EC%9D%B4%EB%A0%A5%20%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/til/java/%EC%8A%A4%ED%8A%B8%EB%A6%BC-joining,-%EC%83%81%EB%8C%80%EB%B0%A9-%EC%BB%A4%EB%B0%8B-%EC%9D%B4%EB%A0%A5-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/"><![CDATA[<h2 id="스트림-colloctorsjoining">스트림 Colloctors.joining()</h2>
<h2 id="상대방-커밋-이력과-코드-가져오기">상대방 커밋 이력과 코드 가져오기</h2>

<ul>
  <li><strong>git remote add <code class="language-plaintext highlighter-rouge">축약할 이름</code> <code class="language-plaintext highlighter-rouge">가져올 상대의 저장소</code></strong></li>
</ul>

<p>내 Local git과 가져올 Github의 저장소의 주소를 연결시켜주기 위해 이 작업이 필요하다.
축약할 이름은 자기가 편한 이름으로 지어주면 된다.
보통 자주 사용하는 <code class="language-plaintext highlighter-rouge">origin</code>도 하나의 이름이다.
git clone 을 하면 자동으로 clone 한 저장소와 연결이 된다. 그 때, 자동으로 origin 이라고 이름이 지어진다.</p>

<p><br /></p>

<ul>
  <li><strong>git fetch <code class="language-plaintext highlighter-rouge">축약이름</code> <code class="language-plaintext highlighter-rouge">브랜치명</code></strong></li>
</ul>

<p>이렇게 작성을 해주면, 내가 입력한 브랜치의 코드들과 커밋만 가져와 준다.</p>

<p><br /></p>

<ul>
  <li><strong>git merge <code class="language-plaintext highlighter-rouge">축약이름</code>/ <code class="language-plaintext highlighter-rouge">브랜치</code></strong></li>
</ul>

<p>커밋 이력은 git log를 통해 확인할 수 있다.
이 작업을 하면, 코드와 커밋 이력이 내 로컬 저장소에 생기게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/154097981-42ca3527-d5f4-4624-b1ad-4e21edf885f9.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/67885363/154098199-df2fdacf-733c-49a7-97bf-920496a52f43.png" alt="image" /></p>]]></content><author><name>kun</name></author><category term="til" /><category term="java" /><summary type="html"><![CDATA[스트림 Colloctors.joining() 상대방 커밋 이력과 코드 가져오기]]></summary></entry><entry><title type="html">2022.02.10 정규표현식, 팩토리 메서드 패턴, 유틸 클래스</title><link href="http://localhost:4000/til/java/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D,-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4,-%EC%9C%A0%ED%8B%B8-%ED%81%B4%EB%9E%98%EC%8A%A4/" rel="alternate" type="text/html" title="2022.02.10 정규표현식, 팩토리 메서드 패턴, 유틸 클래스" /><published>2022-02-10T00:00:00+09:00</published><updated>2022-02-10T00:00:00+09:00</updated><id>http://localhost:4000/til/java/%EC%A0%95%EA%B7%9C%20%ED%91%9C%ED%98%84%EC%8B%9D,%20%ED%8C%A9%ED%86%A0%EB%A6%AC%20%EB%A9%94%EC%84%9C%EB%93%9C%20%ED%8C%A8%ED%84%B4,%20%EC%9C%A0%ED%8B%B8%20%ED%81%B4%EB%9E%98%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/til/java/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D,-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4,-%EC%9C%A0%ED%8B%B8-%ED%81%B4%EB%9E%98%EC%8A%A4/"><![CDATA[<h2 id="정규-표현식">정규 표현식</h2>

<h2 id="팩토리-메서드-패턴">팩토리 메서드 패턴</h2>

<h2 id="유틸-클래스">유틸 클래스</h2>

<p>이렇게 모든 메소드가 static이고 객체를 만들어 쓰지 않는 클래스를 유틸리티 클래스라고 한다.<br />
이 클래스는 인스턴스화 될 필요가 없다. <br />
생성자 사용을 방지하기 위해 기본 생성자를 private으로 만들수도 있다.<br />
상속을 방지하기 위해 클래스를 final로 선언한다. <br />
유틸리티 클래스에서 비즈니스 로직을 다루는 것은 좋지 않다.<br />나 같은 경우는 InputView나 OutputView 같은 뷰클래스들은 유틸 클래스로 만든다.<br />
그리고 상황에 맞게, 인스턴스가 없는 클래스 같은 경우 유틸 클래스로 만들어 효율적으로 관리할 수 있을 것 같다.</p>]]></content><author><name>kun</name></author><category term="til" /><category term="java" /><summary type="html"><![CDATA[정규 표현식]]></summary></entry><entry><title type="html">2022.02.09 Junit</title><link href="http://localhost:4000/til/Junit/" rel="alternate" type="text/html" title="2022.02.09 Junit" /><published>2022-02-09T00:00:00+09:00</published><updated>2022-02-09T00:00:00+09:00</updated><id>http://localhost:4000/til/Junit</id><content type="html" xml:base="http://localhost:4000/til/Junit/"><![CDATA[<p>우테코 첫 미션으로 TDD 기법을 사용해 자동차 경주 게임을 구현한다.<br />
이전에 프로덕션 코드를 작성하고 간단한 단위 테스트 코드를 작성한 적은 있지만 TDD는 처음이다.<br />
지금까지는 Junit은 테스트 코드를 작성하게 지원해주는 라이브러리 정도라고만 알고 있었는데, Junit에 대해 궁금증이 생겨 정리해보았다.<br /></p>

<h2 id="junit5">Junit5</h2>

<p>Junit5는 이전 버전과 다르게 세개의 서브 프로젝트로 이루어져 있다.
Junit5은 <code class="language-plaintext highlighter-rouge">Junit Platform</code> + <code class="language-plaintext highlighter-rouge">Junit Jupiter</code> + <code class="language-plaintext highlighter-rouge">Junit Vintage</code> 이 3개가 합쳐진 것이다.</p>

<ul>
  <li>
    <p><strong>Junit Platform</strong><br />
  Junit Platform은 JVM 테스트 프레임워크를 실행하는데 기초를 제공한다.
  또한 TestEngine API를 제공해 테스트 프레임워크를 개발할 수 있다.</p>
  </li>
  <li>
    <p><strong>Junit Jupiter</strong><br />
  Junit Jupiter는 Junit 5에서 테스트를 작성하고 확장 하기 위한 새로운 프로그래밍 모델과 확장 모델의 조합이다.</p>
  </li>
  <li>
    <p><strong>Junit Vintage</strong><br />
  Junit Vintage는 하위 호환성을 위해 Junit3과 Junit4를 기반으로 돌아가는 플랫폼에 테스트 엔진을 제공한다.</p>

    <p><br /></p>
  </li>
</ul>

<h3 id="displayname">@DisplayName</h3>

<p>테스트 클래스나 테스트 메서드에 이름을 붙여줄 때 사용한다.
테스트를 실행했을 때, 디폴트값은 메서드 이름인데, <code class="language-plaintext highlighter-rouge">@DisplayName</code>을 붙여주면 <code class="language-plaintext highlighter-rouge">@DisplayName</code>의 내용이 출력된다.</p>

<p><br /></p>

<h3 id="beforeeach">@BeforeEach</h3>

<p>각각 테스트 메서드가 실행되기전에 실행되어야 하는 메서드를 명시해준다.
<code class="language-plaintext highlighter-rouge">@Test</code>, <code class="language-plaintext highlighter-rouge">@RepeatedTest</code>, <code class="language-plaintext highlighter-rouge">@ParameterizedTest</code>, <code class="language-plaintext highlighter-rouge">@TestFactory</code> 가 붙은 테스트 메서드가 실행하기 전에 실행된다.
Junit4의 <code class="language-plaintext highlighter-rouge">@Before</code> 와 같은 역할을 한다.</p>

<p><br /></p>

<h3 id="parameterizedtest">@ParameterizedTest</h3>

<p>파라미터화 테스트는 각각 다른 인자로 여러 번 테스트를 돌린다.
호출 시 사용될 인자를 적어도 하나는 적어줘야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@ParameterizedTest</span>
	<span class="nd">@ValueSource</span><span class="o">(</span><span class="n">ints</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">})</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"Set값 전체 존재 확인"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">set값_전체_존재_확인</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">value</span><span class="o">)).</span><span class="na">isTrue</span><span class="o">();</span>
	<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@ValueSource</code>  :  간단하게 하나의 배열로 값을 정의하며, 하나의 인자만 받는 파라미터화 테스트에만 적용할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">@NullSource</code> : <code class="language-plaintext highlighter-rouge">@ParameterizedTest</code> 메서드에 null을 제공한다.</li>
  <li><code class="language-plaintext highlighter-rouge">@EmptySource</code> : 배열 같은 인자에 빈값을 제공한다.</li>
</ul>

<p><br /></p>

<h3 id="csvsource">@CsvSource</h3>

<p><code class="language-plaintext highlighter-rouge">@CsvSource</code> 는 리스트를 delimeter 속성의 구분자로 구분해 준다.
delimeter 속성에 아무것도 입력하지 않는다면 기본값은 콤마를 사용한다.
delimeterString 속성을 쓰면 문자 대신 문자열로 구분자를 사용할 수도 있다.
그러나 delimeter 속성과 delimeterString을 동시에 사용하면 안된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
	<span class="nd">@CsvSource</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1:true"</span><span class="o">,</span> <span class="s">"2:True"</span><span class="o">,</span> <span class="s">"3:true"</span><span class="o">,</span> <span class="s">"4:false"</span><span class="o">,</span> <span class="s">"5:false"</span><span class="o">},</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">':'</span><span class="o">)</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"Set값 존재 여부 구별"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">set값_존재_여부_구별</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">assertThat</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">value</span><span class="o">)).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="assertions">Assertions</h3>

<p>JUnit Jupiter는 JUnit4로부터 온 assertion 메소드와 새롭게 자바 8 람다 표현식으로 추가된 메소드들이 있다. 
모든 JUnit Jupiter assertion은 정적 메소드이며, <code class="language-plaintext highlighter-rouge">org.junit.jupiter.api.Assertions</code> 클래스 안에 있다.</p>

<p><br /></p>

<h2 id="assertj란-무엇인가">AssertJ란 무엇인가</h2>

<p>AsserJ는 많은 assertion을 제공하는 자바 라이브러리다.
에러 메세지와 테스트 코드의 가독성을 매우 높여준다.
<code class="language-plaintext highlighter-rouge">Junit</code>에서 제공하는 assertEquals에 비해 가독성이 더 좋다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEquals</span><span class="o">(</span><span class="n">expected</span><span class="o">,</span> <span class="n">actual</span><span class="o">);</span>
<span class="n">assertThat</span><span class="o">(</span><span class="n">actual</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">expected</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="exception-처리-test">Exception 처리 test</h3>

<ul>
  <li><strong>assertThatThrownBy()</strong> 
예외 처리를 가독성 있게 테스트할 수 있게 해준다.
기존에는 Throwable을 가지고 검증 했다면, 좀 더 나은 가독성으로 작성하게 해준다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">공백_이름</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">assertThatThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="s">""</span><span class="o">))</span>
			<span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
			<span class="o">.</span><span class="na">hasMessage</span><span class="o">(</span><span class="no">EMPTY_NAME_ERROR</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>assertThatExceptionOfType</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"IndexOutOfBoundsException 발생"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">indexOutOfBoundsException_발생</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">assertThatExceptionOfType</span><span class="o">(</span><span class="nc">IndexOutOfBoundsException</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">isThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">errorIndex</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
			<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">errorIndex</span><span class="o">));</span>
		<span class="o">});</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>AssertJ에서 자주 발생하는 예외들에 대해 정의된 함수를 제공한다.
<code class="language-plaintext highlighter-rouge">NullPointerException</code>, <code class="language-plaintext highlighter-rouge">IllegalArgumentException</code>, <code class="language-plaintext highlighter-rouge">IllegalStateException</code>, <code class="language-plaintext highlighter-rouge">IOException</code>이 있다.</p>

<ul>
  <li><strong>assertThatIoException</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Test</span>
	<span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"Exception Message 검사"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="n">exception_message_검사</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">assertThatIOException</span><span class="o">().</span><span class="na">isThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"exception message test"</span><span class="o">);</span>
		<span class="o">}).</span><span class="na">withMessage</span><span class="o">(</span><span class="s">"exception message test"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>참고<br />
<a href="https://pjh3749.tistory.com/241">https://pjh3749.tistory.com/241</a><br />
<a href="https://donghyeon.dev/junit/2021/04/11/JUnit5-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C/">https://donghyeon.dev/junit/2021/04/11/JUnit5-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C/</a></p>]]></content><author><name>kun</name></author><category term="til" /><summary type="html"><![CDATA[우테코 첫 미션으로 TDD 기법을 사용해 자동차 경주 게임을 구현한다. 이전에 프로덕션 코드를 작성하고 간단한 단위 테스트 코드를 작성한 적은 있지만 TDD는 처음이다. 지금까지는 Junit은 테스트 코드를 작성하게 지원해주는 라이브러리 정도라고만 알고 있었는데, Junit에 대해 궁금증이 생겨 정리해보았다.]]></summary></entry><entry><title type="html">JDK, JRE, JVM</title><link href="http://localhost:4000/java/JDK,JRE,JVM/" rel="alternate" type="text/html" title="JDK, JRE, JVM" /><published>2022-02-06T00:00:00+09:00</published><updated>2022-02-06T00:00:00+09:00</updated><id>http://localhost:4000/java/JDK,JRE,JVM</id><content type="html" xml:base="http://localhost:4000/java/JDK,JRE,JVM/"><![CDATA[<p><img src="https://user-images.githubusercontent.com/67885363/152673863-89540ec5-c5b8-4ade-9f61-d1bf528175cd.jpeg" alt="jdk" /></p>

<p><img src="https://user-images.githubusercontent.com/67885363/152673876-68b6211c-8f99-4255-aa5c-e6a17f9dbb31.png" alt="JVM_JRE_JDK" /></p>

<h1 id="jdk-java-development-kit">JDK (Java Development Kit)</h1>

<p>JDK란 Java를 활용하여 프로그램을 개발할 때 필요한 도구 모음이다. <br />JRE는 Java 프로그램을 실행하기 위한 도구들의 구성요소로 독립적으로 사용 가능하다. <br />하지만 프로그램을 실행시키는 것도 개발의 일환이기 때문에 JDK는 JRE를 필요로 한다.</p>

<p><br /></p>

<p><strong>JDK 구성요소</strong></p>

<ul>
  <li>javac : 자바 컴파일러. 자바 소스파일을 바이트코드로 반환</li>
  <li>jdb : 자바 디버깅 툴</li>
  <li>jar : 서로 관련있는 클래스 라이브러리들과 리소스를 하나의 파일로 묶어주는 툴</li>
</ul>

<p><br /></p>

<p><strong>JDK 종류</strong></p>

<ul>
  <li>
    <p>Java SE (Java Standard Edition)<br />: 표준 에디션의 자바 플랫폼이다. 자바 언어의 핵심 기능을 제공한다. 주요 패키지는 java.lang , java.io , java.util, java.awt 등이 있다.</p>
  </li>
  <li>
    <p>Java EE (Java Enterprise Edition)<br />: Java SE에 웹 어플리케이션 서버에서 동작하는 기능을 추가한 플랫폼이다.  JSP, Servlet, JDBC 등 기업용 어플리케이션을 개발하는데 필요한 다양한 것들이 포함된 플랫폼이다.</p>
  </li>
  <li>
    <p>Java ME (Java Micro Edition)<br />: 임베디드 기기들에서 구동되기 위한 환경을 제공하는 API를 모아둔 플랫폼이다. 휴대전화, PDA 등에서 Java 프로그래밍 언어를 지원하기 위해 만든 플랫폼 중 하나이다.</p>

    <p><br /></p>
  </li>
</ul>

<h1 id="jre-java-runtime-environment">JRE (Java Runtime Environment)</h1>

<p>JVM 위에서 .class 파일이 원활하게 작동하기 위해서는 몇 가지 필수적인 요소들이 필요하는데 이를 제공해주는 것이 JRE다.<br /> JRE는 크게 JVM과 Java Class Libraries, Class Loader라는 요소로 구성이 된다.</p>

<p><br /></p>

<p><strong>Java Class Libraries</strong></p>

<p>Java를 실행시키는데 필수적인 라이브러리다.<br />java.io, java.util, java.thread, java.lang 등 작동에 필수적인 요소들을 가지고 있다.<br />JVM에 올라가는 바이트 코드에서도 필수 라이브러리를 참고하고 있기 때문에 간단한 코드라도 필수 라이브러리가 필요하다.</p>

<p><br /></p>

<p><strong>Class Loader</strong></p>

<p>필요한 클래스들을 JVM 위로 올려주는 역할을 한다. <br />Javac를 통해 생성된 .class 파일은 각 디렉토리에 흩어져 있다.<br />그리고 라이브러리의 클래스 파일들은 $JAVAHOME_ 내부 경로에 존재한다.<br />이러한 각각의 클래스 파일들을 찾아서 JVM의 메모리에 탑재해주는 역할을 하는 것이 ClassLoader 이다.</p>

<p>ClassLoader 는 크게 Loading, Linking, 그리고 Initialization 3가지 역할을 맡게 된다.<br /> Loading 은 클래스 파일을 탑재하는 과정, Linking 은 클래스 파일을 사용하기 위해 검증하고, 기본 값으로 초기화하는 과정이다. Initialization 은 static field 의 값들을 개발자가 정의한 값으로 초기화를 하는 과정이다.</p>

<p><br /></p>

<h1 id="jvm-java-virtual-machine">JVM (Java Virtual Machine)</h1>

<p>JVM은 Java로 작성된 프로그램이 돌아가도록 만들어준다.<br />Java로 작성된 프로그램은 운영체제에 맞는 실행파일로 컴파일되는 것이 아닌 .class라는 확장자를 가진 파일로 변환이 되는데 이 .class 파일이 JVM위에서 작동하는 것이고 JVM이 .class 파일에 환경을 제공해준다.<br />JVM은 자바 인터프리터, JIT 커파일러, 가비지 컬렉터로 구성되어 있다.</p>

<p><br /></p>

<p><strong>Java Interpreter</strong></p>

<p>자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할을 하는 것이 자바 인터프리터다.</p>

<p><br /></p>

<p><strong>JIT 컴파일러 (Just In Time compiler)</strong></p>

<p>JIT 컴파일러란 런타임에 자바 바이트 코드를 실제 기계어로 변환해주는 컴파일러를 의미한다. 프로그램의 실행 속도를 향상시키기 위해 동적 번역이라는 기법을 사용한다.</p>

<p><br /></p>

<p><strong>Garbage Collector</strong></p>

<p>jvm은 가비지 컬렉터를 이용해 더는 사용하지 않는 메모리를 자동으로 회수해 준다.</p>

<p><br /></p>

<h3 id="정리">정리</h3>

<p><img src="https://user-images.githubusercontent.com/67885363/152675147-e4b7c544-68cf-40bf-813c-e4cabcbf8a9c.png" alt="img_java_programming" /></p>

<p>우리가 작성하는 자바 클래스 파일(.java)은 JDK의 자바 컴파일러(javac) 를 통해 자바 바이트 코드(.class) 로 변환하게 된다.</p>

<p>자바 컴파일러에 의해 생성된 자바 바이트 코드는 운영체제에 상관없이 JVM 위에서 작동이 되기 때문에 Java가 이식성이 좋은 것이다.</p>

<p>그리고 바이트 코드가 JVM 위에서 원활하게 작동이 되기 위해서는 필수적인 자바 라이브러리나 우리가 작성한 클래스 파일들이 필요하는데, 이러한 각각의 클래스 파일들을 JVM 위에 올려주는 역할을 하는 것이 JRE이다.</p>

<p><br /></p>

<p>참고</p>

<p>https://www.codejava.net/java-core/what-are-jvm-jre-and-jdk<br />
https://tecoble.techcourse.co.kr/post/2021-07-15-jvm-classloader/<br />
https://tecoble.techcourse.co.kr/post/2021-07-12-jvm-jre-jdk/<br />
http://www.tcpschool.com/java/java_intro_programming</p>]]></content><author><name>kun</name></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry></feed>