<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-24T03:12:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Keep Going</title><author><name>kun</name></author><entry><title type="html">Application Context를 재활용해서 테스트 시간을 줄이자</title><link href="http://localhost:4000/spring/test/checkmate/Application-Context%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%A4%84%EC%9D%B4%EC%9E%90/" rel="alternate" type="text/html" title="Application Context를 재활용해서 테스트 시간을 줄이자" /><published>2022-08-28T00:00:00+09:00</published><updated>2022-08-28T00:00:00+09:00</updated><id>http://localhost:4000/spring/test/checkmate/Application%20Context%EB%A5%BC%20%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%8B%9C%EA%B0%84%EC%9D%84%20%EC%A4%84%EC%9D%B4%EC%9E%90</id><content type="html" xml:base="http://localhost:4000/spring/test/checkmate/Application-Context%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%A4%84%EC%9D%B4%EC%9E%90/"><![CDATA[<h1 id="application-context를-재활용해서-테스트-시간을-줄이자">Application Context를 재활용해서 테스트 시간을 줄이자</h1>

<p>JUnit은 테스트 메서드를 실행할 때마다 매번 테스트 클래스의 새로운 오브젝트를 만든다. 따라서 모든 테스트는 서로 영향을 주지 않으며 독립적으로 실행되는 것을 보장한다. 하지만 테스트가 독립적이라고 해서 매번 Application Context를 새로 만드는 건 매우 비효율적이다.</p>

<p>스프링은 이러한 문제를 해결하기 위해 Context Caching 기능을 제공한다. Spring 테스트 컨텍스트 프레임워크는 한번 ApplicationContext가 만들어지면 이를 캐시에 저장하고 다른 테스트를 돌릴 때 환경이 같으면 재사용한다.</p>

<p>스프링 테스트 컨텍스트 프레임워크는 테스트 클래스의 여러 configuration으로 key를 구성하는데, 이 key가 같으면 환경이 같은 것이다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">locations</code> (from <code class="language-plaintext highlighter-rouge">@ContextConfiguration</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">classes</code> (from <code class="language-plaintext highlighter-rouge">@ContextConfiguration</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">contextInitializerClasses</code> (from <code class="language-plaintext highlighter-rouge">@ContextConfiguration</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">contextCustomizers</code> (from <code class="language-plaintext highlighter-rouge">ContextCustomizerFactory</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">contextLoader</code> (from <code class="language-plaintext highlighter-rouge">@ContextConfiguration</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">parent</code> (from <code class="language-plaintext highlighter-rouge">@ContextHierarchy</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">activeProfiles</code> (from <code class="language-plaintext highlighter-rouge">@ActiveProfiles</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">propertySourceLocations</code> (from <code class="language-plaintext highlighter-rouge">@TestPropertySource</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">propertySourceProperties</code> (from <code class="language-plaintext highlighter-rouge">@TestPropertySource</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">resourceBasePath</code> (from <code class="language-plaintext highlighter-rouge">@WebAppConfiguration</code>)</li>
</ul>

<p>우리 팀은 테스트 코드를 작성할 때 해당 테스트를 위한 ApplicationContext를 xml 파일로 따로 관리하고 있지 않기 때문에 캐싱을 하기 위해 신경 쓸 부분은 빈의 상태(mockbean인지 진짜 빈인지) 밖에 없었다.</p>

<blockquote>
  <p>빈을 @MockBean으로 사용할 경우 ContextCustomizers에 MockitoContextCustomizer가 추가되게 되고 cache key가 달라지면서 Application Context를 재사용하지 못하게 된다.</p>
</blockquote>

<p>우리팀은 Controller Test에서 Service 클래스를 mocking 하고 있는 슬라이싱 테스트를 하고 있다. 각 클래스는 필요한 서비스 클래스를 @MockBean으로 주입받고 있기 때문에 모든 테스트 클래스가 환경이 달라 ApplicationContext가 재사용되고 있지 않았다.</p>]]></content><author><name>kun</name></author><category term="spring" /><category term="test" /><category term="checkmate" /><summary type="html"><![CDATA[Application Context를 재활용해서 테스트 시간을 줄이자]]></summary></entry><entry><title type="html">시간에 독립적인 테스트를 위한 코드 작성하기</title><link href="http://localhost:4000/spring/test/checkmate/%EC%8B%9C%EA%B0%84%EC%97%90-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="시간에 독립적인 테스트를 위한 코드 작성하기" /><published>2022-08-21T00:00:00+09:00</published><updated>2022-08-21T00:00:00+09:00</updated><id>http://localhost:4000/spring/test/checkmate/%EC%8B%9C%EA%B0%84%EC%97%90%20%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8%20%EC%BD%94%EB%93%9C%20%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/spring/test/checkmate/%EC%8B%9C%EA%B0%84%EC%97%90-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/"><![CDATA[<p>지금 진행하고 있는 프로젝트인 체크메이트는 출결 관리 서비스이다. 출석이라는 도메인 자체가 시간과 밀접해있기 때문에 시간에 따라 도메인의 상태가 많이 변경된다. 
예를 들어, 미팅 시작 시간 30분 전부터 미팅 시작 시간 5분 후 까지는 출석부가 수정이 허용되고, 출석 허용시간이 끝나면 출결 상태가 출석이 아닌 회원들은 지각으로 바뀌어야 하는 등 기능의 요구사항들과 시간이 굉장히 밀접하다.</p>

<p>시간과 밀접한 기능에 대한 로직을 작성할 때,  <code class="language-plaintext highlighter-rouge">LocalDateTime.now()</code>(요청이 들어오는 시간) 를 이용하게 되니 시간에 따라 테스트의 성공 여부가 달라지게 되었고 시간에 의존적이지 않은 테스트 코드를 작성하기 위해 고민하게 되었다.</p>

<p><br /></p>

<p>하나의 예시에 대해 살펴보겠다. 아래의 코드는 출석체크를 하는 메서드인데 코드를 간단하게 설명을 하자면,
<img src="https://user-images.githubusercontent.com/67885363/197393566-17ae8e73-fe15-40d2-86e9-a835c59a1791.png" alt="image" /></p>

<ul>
  <li>pathVariable로 받는 meetingId와 UserId에 대해 존재하는 id인지 확인한다.</li>
  <li>요청을 보내는 날짜에 미팅의 이벤트가 있는지 확인하고 일정이 있으면 참가자에 대한 출석처리를 한다.</li>
  <li>요청을 보내는 날짜에 미팅의 이벤트가 존재하지 않으면 예외를 발생한다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/67885363/197397021-9cc1cf01-45f9-4488-8c2e-c04169c09a1e.png" alt="image" /></p>

<p>위 테스트 코드에서 이벤트 객체는 2022년 8월 1일로 저장되었다. 
현재 프로덕션 코드에서는 <code class="language-plaintext highlighter-rouge">LocalDate.now</code>로 조회를 하고 있기 때문에 테스트 돌리는 날짜에 따라 이벤트가 존재하는지 조회하는 날짜가 달라지게 되고 아래의 테스트 코드는 2022년 8월 1일에만 통과하게 된다.</p>

<p>이 문제를 해결하기 위해 요청 시간을 관리하는 객체를 만들어, 테스트 클래스에서는 가짜 객체를 주입받아 시간을 지정할 수 있게 하고자 하였다. 그리고 출석 시간인지 판단하고, 출석 종료 시간을 계산하는 로직들이 반복되고 있음을 깨닫고 시간에 관련된 비즈니스 로직을 처리하고자 하는 객체를 만들고자 했다.</p>

<p><br /></p>

<p>먼저 LocalDateTime을 필드로 가지는 DateTime이라는 추상 클래스를 만들었다. 
<img src="https://user-images.githubusercontent.com/67885363/197398112-3ee581ad-0142-48f0-aa5b-28d14f8ab581.png" alt="image" /></p>

<ul>
  <li>
    <p>프로덕션 코드에서는 ServerDateTime이라는 객체를 사용되게 하고자 했고
<img src="https://user-images.githubusercontent.com/67885363/197401384-e441154a-496b-4b08-9379-f439073125e8.png" alt="image" /></p>
  </li>
  <li>
    <p>테스트 코드에서는 FakeDateTime 객체가 사용되게 하고자 했다.
<img src="https://user-images.githubusercontent.com/67885363/197398309-1ac7653b-2e04-4e29-90a8-e5126efd049f.png" alt="image" />
그러기 위해서 이 FakeDateTime의 객체 위치를 test 패키지 하위에 배치했고, @Primary 어노테이션이 붙여주었다.</p>
  </li>
</ul>

<blockquote>
  <p>사실 @Primary 어노테이션은 이런 용도로 사용하는 것이 아닐수도 있다.</p>

  <p>@Autowired 시에 여러 빈이 매칭될 때 @Primary가 붙은 빈을 우선권을 가지게 하고자 할 때 사용하는 것이다.</p>

  <p>정석적인 방법으로는 @TestConfiguration을 이용해서 테스트 환경을 위한 빈을 정의하는 것이 맞았을수도 있지만, 아래와 같은 방법이 더 편하기도 하고 신기해서 사용했다.</p>

  <p>main과 test 모듈이 달라서 test에 있는 먼저 빈을 읽은건가 싶어서 @Primary를 삭제해보았는데 ServerDateTime 객체가 주입받게 되었고 테스트에 실패하는 것을 확인할 수 있었다.</p>
</blockquote>

<p><br /></p>

<p>그리고 이 DateTime을 필드로 가지고 있고 시간에 관련된 비즈니스 로직을 처리하는 ServerTimeManager라는 객체를 만들었다. 각 서비스 클래스들은 이 클래스를 주입받아 시간에 대한 처리를 하고 있다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/197399128-ad71fedd-d312-49b0-9ebb-85ef18b41a93.png" alt="image" /></p>

<p>각 Service 클래스는 빈 스코프를 따로 설정해주지 않기 때문에 싱글톤 스코프다.</p>

<p>하지만 이 ServerTimeManager의 DateTime은 요청이 들어오는 시간에 따라 (빈을 사용할 때마다) 빈이 새로 생성이 되어야한다. 그래서 빈 스코프를 prototype으로 할지, request로 할 지 고민이 들었는데 request가 더 간편해서 request로 결정하게 되었다.</p>

<blockquote>
  <p>프로토타입 스코프 - 싱글톤 빈과 함께 사용시 주의할 점</p>

  <p>그리고 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 처음 주입받은 프로토타입 빈과 함께 계속 유지된다. (프로토타입 빈은 컨테이너가 빈을 생성하고 초기화할 때까지만 관리하고 종료 시점까지 관리하지 않는다. )</p>

  <p>그래서 프로토타입 빈을 사용할 때마다 ApplicationContext에서 직접 조회하는 로직이 수행되어야 하는데, 이런 것들을 간편하게 해주는 Provider 같은 라이브러리를 사용해야 한다.</p>

  <p>반면 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리한다.</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><category term="test" /><category term="checkmate" /><summary type="html"><![CDATA[지금 진행하고 있는 프로젝트인 체크메이트는 출결 관리 서비스이다. 출석이라는 도메인 자체가 시간과 밀접해있기 때문에 시간에 따라 도메인의 상태가 많이 변경된다. 예를 들어, 미팅 시작 시간 30분 전부터 미팅 시작 시간 5분 후 까지는 출석부가 수정이 허용되고, 출석 허용시간이 끝나면 출결 상태가 출석이 아닌 회원들은 지각으로 바뀌어야 하는 등 기능의 요구사항들과 시간이 굉장히 밀접하다.]]></summary></entry><entry><title type="html">서비스 계층을 테스트할 때 @Transactional 사용을 지양하자</title><link href="http://localhost:4000/spring/test/checkmate/Service-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C-@Transactional%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4/" rel="alternate" type="text/html" title="서비스 계층을 테스트할 때 @Transactional 사용을 지양하자" /><published>2022-08-14T00:00:00+09:00</published><updated>2022-08-14T00:00:00+09:00</updated><id>http://localhost:4000/spring/test/checkmate/Service%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C%20@Transactional%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4%20%EC%95%88%EB%90%9C%EB%8B%A4</id><content type="html" xml:base="http://localhost:4000/spring/test/checkmate/Service-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C-@Transactional%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4/"><![CDATA[<p>보통 우리는 여러 repository 메서드를를 실행시키는(DB에 접근하는) Service 계층에서 원자성을 보장하기 위해 <code class="language-plaintext highlighter-rouge">@Transactional</code> 어노테이션을 붙여줍니다.</p>

<p>트랜잭션 관리는 서비스 계층의 역할 중에서 가장 중요하다고 볼 수도 있는 역할이라고 생각을 하는데요.</p>

<p>단순히 테스트 격리를 위해서 Service 테스트 클래스에서 @Transactional을 붙여주게 된다면 각 서비스 메서드들은 테스트 클래스의 트랜잭션에 참여하게 되기 때문에 서비스 계층의 트랜잭션 관리를 테스트하고 있다고 볼 수 없게 됩니다.</p>

<p>그리고 JPA를 사용한다고 했을 때, 스프링 컨테이너는 기본 전략으로 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위를 같게 하는 전략을 사용하기 때문에, 서비스 계층의 메서드들은 테스트 클래스의 영속성 컨텍스트에 참여하게 되는 것입니다.</p>

<p>만약 서비스 메서드에서 지연 로딩을 위해 트랜잭션이 필요한 상황에 실수로 @Transactional을 붙여주지 않아서 예외가 발생해야 되는 상황인데,  서비스 테스트 클래스의 트랜잭션에 참여하게 된다면 예외가 발생하지 않게 되는 올바르지 않는 테스트를 하고 있을 수도 있는거죠.</p>

<p>그러기 때문에 단순히 테스트 격리를 위해 @Transactional 을 사용하는 것은 지양하는 것이 좋을 것 같습니다. 대안으로 @sql 어노테이션을 이용하거나 EntityManager로 Truncate 쿼리문을 실행시키는 방법이 좋아보입니다.</p>]]></content><author><name>kun</name></author><category term="spring" /><category term="test" /><category term="checkmate" /><summary type="html"><![CDATA[보통 우리는 여러 repository 메서드를를 실행시키는(DB에 접근하는) Service 계층에서 원자성을 보장하기 위해 @Transactional 어노테이션을 붙여줍니다.]]></summary></entry><entry><title type="html">인수테스트 격리하기</title><link href="http://localhost:4000/spring/test/checkmate/%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B2%A9%EB%A6%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="인수테스트 격리하기" /><published>2022-08-07T00:00:00+09:00</published><updated>2022-08-07T00:00:00+09:00</updated><id>http://localhost:4000/spring/test/checkmate/%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EA%B2%A9%EB%A6%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/spring/test/checkmate/%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B2%A9%EB%A6%AC%ED%95%98%EA%B8%B0/"><![CDATA[<p>인수테스트란 사용자 시나리오에 맞춰서 실제 운영 환경에서 사용될 준비가 되었는지를 통합적으로 확인하는 테스트다.</p>

<p>인수 테스트의 목적이 실제 운영 환경과 같은 조건을 테스트하고자 하는 것이기 때문에 mock 프레임워크 등을 사용하지 않고 실제 데이터베이스를 사용해야 조건에 충족할 수 있다.</p>

<p>그러므로 테스트가 실행되면서 데이터베이스의 상태는 변하게 되고 테스트는 데이터베이스의 상태에 따라 성공 여부가 달라지게 될 것이다.</p>

<p>데이터베이스의 상태에 의존받지 않기 위해 테스트를 효과적으로 격리해야한다.</p>

<h3 id="dirtiescontext">@DirtiesContext</h3>

<p><img src="https://user-images.githubusercontent.com/67885363/196947575-adab8873-debe-40ad-861c-6e7ccd20b3e1.png" alt="image" /></p>

<p>이 @DirtiesContext 는 classMode에 따라 Spring Context를 새로 로드한다. 우리는 classMode를 <code class="language-plaintext highlighter-rouge">BEFORE_EACH_TEST_METHOD</code>로 지정했기 때문에 모든 테스트 메서드마다 시작하기 이전에 contexts를 재생성했다.</p>

<p>메서드마다 context를 새로 로드하기 때문에 격리는 잘 되었지만 문제가 있었다.</p>

<p>테스트 갯수가 얼마되지 않았을 때에는 실행할 때 체감할 수 있을 정도로 많은 시간이 걸리지 않았지만, 점점 테스트 갯수가 많아지면서 시간이 너무 오래걸리게 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/196950043-46a190e1-c99c-41f5-9a69-063a1ec49381.png" alt="image" /></p>

<p>총 51개의 인수테스트가 실행되는데 2분 29초이나 걸렸다. 다른 격리하는 방법을 찾게 되었다.</p>

<p><br /></p>

<h3 id="sql">@SQL</h3>

<p><img src="https://user-images.githubusercontent.com/67885363/197001536-ffa71a2b-7f20-495a-959d-e0e15d04d3fe.png" alt="image" /></p>

<p>스트링 부트에서 제공하는 어노테이션이다. executionPhase의 속성이 <code class="language-plaintext highlighter-rouge">BEFORE_TEST_METHOD</code>이기 때문에 실행되기 전에 @sql이 가리키는 경로에 있는 SQL 실행이 먼저 일어나고 있다. executionPhase 속성의 기본 값이 <code class="language-plaintext highlighter-rouge">BEFORE_TEST_METHOD</code> 이다.</p>

<p>그리고 sql 파일에는 모든 데이터를 지워주는 쿼리문을 작성해주면 된다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">attendance</span><span class="p">;</span>
<span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">event</span><span class="p">;</span>
<span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">participant</span><span class="p">;</span>
<span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="n">meeting</span><span class="p">;</span>
<span class="k">TRUNCATE</span> <span class="k">TABLE</span> <span class="k">user</span><span class="p">;</span>
</code></pre></div></div>

<p>좋은 방식이지만 sql 파일을 계속 관리해주어야 하는 단점이 있다. 만약 새로운 테이블이 추가되면 sql 파일에도 추가를 해주어야한다. 엔티티 구조가 간단하면 사용할만 하지만, 엔티티가 정말 많아진다면 sql 파일 관리하는 것도 많이 귀찮아질 것이다.</p>

<p><br /></p>

<h3 id="entitymanager로-truncate-쿼리-실행시키기">EntityManager로 TRUNCATE 쿼리 실행시키기</h3>

<p><img src="https://user-images.githubusercontent.com/67885363/197004856-c48f1c71-8e7b-48e4-91fc-d88fbf3b39e7.png" alt="image" /></p>

<p>이 방법은 EntityManager를 빈으로 주입 받아 모든 테이블 이름을 List에 추가한 후 List를 for문으로 돌면서 <code class="language-plaintext highlighter-rouge">TRUNCATE</code> 쿼리문을 실행시켜주는 것이다.</p>

<p>위의 init 메서드를 빈이 생성될 때 자동으로 실행될 수 있게 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션을 붙여주면서 따로 메서드를 실행시키지 않게 해주었다. 테스트 클래스에서는 Junit의 <code class="language-plaintext highlighter-rouge">@BeforeEach</code>로 execute 메서드를 실행시켜주면 테이블의 모든 데이터를 지우면서 격리시킬 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/197008774-a7b85b0f-a5da-456a-81be-7555d3be6cf1.png" alt="image" /></p>

<p>이 방법은 DirtiesContext처럼 spring context를 새로 로드하지 않기 때문에 시간이 많이 걸리지 않게 되고 @sql 방법처럼 따로 sql 파일을 관리하지 않아도 되므로 가장 좋은 방법으로 보인다.</p>]]></content><author><name>kun</name></author><category term="spring" /><category term="test" /><category term="checkmate" /><summary type="html"><![CDATA[인수테스트란 사용자 시나리오에 맞춰서 실제 운영 환경에서 사용될 준비가 되었는지를 통합적으로 확인하는 테스트다.]]></summary></entry><entry><title type="html">aws ec2 살펴보기1 (리전, 가용 영역)</title><link href="http://localhost:4000/infra/aws-ec2-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B01-(%EB%A6%AC%EC%A0%84,-%EA%B0%80%EC%9A%A9-%EC%98%81%EC%97%AD)/" rel="alternate" type="text/html" title="aws ec2 살펴보기1 (리전, 가용 영역)" /><published>2022-07-28T00:00:00+09:00</published><updated>2022-07-28T00:00:00+09:00</updated><id>http://localhost:4000/infra/aws%20ec2%20%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B01%20(%EB%A6%AC%EC%A0%84,%20%EA%B0%80%EC%9A%A9%20%EC%98%81%EC%97%AD)</id><content type="html" xml:base="http://localhost:4000/infra/aws-ec2-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B01-(%EB%A6%AC%EC%A0%84,-%EA%B0%80%EC%9A%A9-%EC%98%81%EC%97%AD)/"><![CDATA[<h2 id="리전">리전</h2>
<p>aws 리전이란 aws 리소스를 지리적 관점으로 영역으로 구분해놓은 것이다. 각 aws 리전은 격리되어 있고 독립적이다. 내가 만약 서울 리전에서 리소스를 만들었다면 미국 동부(오하이오) 리전에서 사용할 수 없다.</p>

<p>리전은 전 세계적으로 여러 곳에 존재하고 있기 때문에 재해 발생시에도 서비스를 공급할 수 있고 사용자는 자신의 위치와 가장 가까운 리전을 선택함으로서 빠른 서비스를 이용할 수 있다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/ded36692-320b-4334-8e23-ff7ecf8abbda/image.png" alt="" /></p>

<p><br /></p>

<h2 id="가용-영역-avaliability-zone">가용 영역 (Avaliability Zone)</h2>
<p>가용 영역이란 aws 리전 내에서 격리된 위치다. 리전은 일반적으로 3개 이상의 가용 영역으로 구성되어 있는데 낙뢰, 지진과 같은 자연재에서의 연쇄적인 피해를 보호하기 위해 물리적으로 유의미한 거리를 두고 설치한다.</p>

<p>가용 영역은 하나 이상의 개별 데이터 센터로 구성되고 개별 데이터 센터에는 일반적으로 50,000 ~ 80,000대의 물리적 서버가 있다고 한다.</p>

<p>리전의 모든 가용영역은 전용 메트로 광 네트워크로 연결되어 있어 높은 처리량과 지연 시간이 짧은 네트워킹을 제공한다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/9e1a7f97-6e62-437c-9c20-02b76dcc7ab4/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/85e38e00-bc69-45d8-926a-c9e79dec304f/image.png" alt="" /></p>

<blockquote>
  <p>참고
https://docs.aws.amazon.com/ko_kr/general/latest/gr/rande-manage.html
https://aws.amazon.com/ko/about-aws/global-infrastructure/regions_az/</p>
</blockquote>]]></content><author><name>kun</name></author><category term="infra" /><summary type="html"><![CDATA[리전 aws 리전이란 aws 리소스를 지리적 관점으로 영역으로 구분해놓은 것이다. 각 aws 리전은 격리되어 있고 독립적이다. 내가 만약 서울 리전에서 리소스를 만들었다면 미국 동부(오하이오) 리전에서 사용할 수 없다.]]></summary></entry><entry><title type="html">JPQL 벌크 연산을 주의하자</title><link href="http://localhost:4000/jpa/JPQL-%EB%B2%8C%ED%81%AC-%EC%97%B0%EC%82%B0/" rel="alternate" type="text/html" title="JPQL 벌크 연산을 주의하자" /><published>2022-07-17T00:00:00+09:00</published><updated>2022-07-17T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPQL%20%EB%B2%8C%ED%81%AC%20%EC%97%B0%EC%82%B0</id><content type="html" xml:base="http://localhost:4000/jpa/JPQL-%EB%B2%8C%ED%81%AC-%EC%97%B0%EC%82%B0/"><![CDATA[<h2 id="jpql-벌크-연산">JPQL 벌크 연산</h2>
<p>엔티티를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나, 삭제하려면 entityManger.remove() 메서드를 사용할 수 있다.
하지만 이 방법으로 수백 개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다.
이럴 때 여러 건을 한번에 수정하거나 삭제하는 벌크 연산을 사용할 수 있다.</p>

<h3 id="벌크-연산의-주의점">벌크 연산의 주의점</h3>
<p>하지만 벌크 연산을 사용할 때는 벌크 연산이 영속성 컨텍스트의 변경감지나 이런 특징들을 이용하지 않고 데이터베이스에 직접 쿼리한다는 점에 주의를 해야한다.
한 상황을 예시로 들어보겠다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/17b27ddc-5fb0-40d3-9717-86e7d610e0dc/image.png" alt="" />
한 사용자의 모든 질문들의 내용들을 변경하는 JPQL 메서드가 있다고 하자.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/317f603c-6759-467f-85cf-31da34f76779/image.png" alt="" /></p>
<ol>
  <li>User의 ID가 1인 질문을 조회하였다.</li>
  <li>벌크 연산으로 질문의 내용을 모두 hot!! 으로 변경시켰다.</li>
  <li>벌크 연산을 수행한 후에 질문의 내용을 확인해보았을 때 hot!! 으로 변경되지 않았다.</li>
</ol>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/c5202f7d-7be7-43af-b381-6c81dff14211/image.png" alt="" /></p>

<p>처음 조회를 했을 때 question 객체가 영속성 컨텍스트가 관리된다.
벌크 연산은 영속성 컨텍스트를 통하지 않고 데이터베이스에 직접 쿼리한다. 데이터베이스에서는 question의 내용은 hot!!으로 변경되었을 것이다.
이렇게 영속성 컨텍스트의 객체 상태와 데이터베이스에 데이터의 값이 다르게 되기 때문에 주의해서 사용해야 한다.</p>

<ul>
  <li>entitymanager.refresh() 사용하기
데이터베이스에서 데이터를 다시 조회해온다.</li>
</ul>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/b66eef58-b1bd-42fd-a9cd-92274e1a12ca/image.png" alt="" /></p>

<ul>
  <li>벌크 연산 수행 후 영속성 컨텍스트 초기화
벌크 연산을 수행한 직후에 영속성 컨텍스트를 초기화해서 비어준다.
그 후에 새로 엔티티를 조회해서 데이터베이스에서 엔티티를 조회한 후에 영속성 컨텍스트에 보관하게 하자.</li>
</ul>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/7eec81c1-4bd4-4bd1-a365-24df328b1473/image.png" alt="" /></p>

<p>아래의 그림과 같이 JPQL이 영속성 컨텍스트를 거치지 않고 데이터베이스로 직접 변경한 데이터를 다시 조회해오게 하면 된다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/20b0415f-ffb2-4c69-916f-2552ab020264/image.png" alt="" /></p>

<p><br /></p>

<h2 id="영속성-컨텍스트와-jpql">영속성 컨텍스트와 JPQL</h2>
<p>JPQL 조회 대상으로 엔티티, 임베디드, 값 등 여러가지 종류가 있을텐데 JPQL로 엔티티를 조회하면 영속성 컨텍스트에서 관리되지만 엔티티가 아니면 영속성 컨텍스트에 관리되지 않는다.</p>

<h3 id="jpql로-조회한-엔티티와-영속성-컨텍스트">JPQL로 조회한 엔티티와 영속성 컨텍스트</h3>
<p>JPQL로 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 이미 있으면 JPQL로 데이터베이스에서 조회한 결과를 버리고 대신에 영속성 컨텍스트에 있던 엔티티를 반환한다.</p>

<p>왜 영속성 컨텍스트에 있는 기존 엔티티를 반환하는 것일까?
일단 영속성 컨텍스트는 기본 키 값을 기준으로 엔티티를 관리하기때문에 같은 기본 키 값을 가진 엔티티는 등록할 수 없다.
그리고 영속성 컨텍스트에 있던 데이터가 수정중인데 JPQL로 새로 검색한 엔티티로 대체하게 되면 위험하다.
또한 영속성 컨텍스트는 엔티티의 동일성을 보장하기 때문에 새로 검색한 엔티티를 버리고 기존 엔티티를 그대로 두게 되는 것이다.</p>

<h3 id="jpql과-플러시-모드">JPQL과 플러시 모드</h3>
<p>기본적으로 entityManager의 플러시 모드는 Auto이다.</p>
<blockquote>
  <p>FlushModeType.AUTO : 커밋 또는 쿼리 실행시 플러시 (기본 값)
FlushModeType.COMMIT : 커밋시에만 플러시</p>
</blockquote>

<p>기존에 영속성 컨텍스트에 있던 User 객체가 닉네임이 kun에서 kun2로 변경되어 쓰기 지연 저장소에 update 쿼리를 보관중이다.
JPQL로 kun2 닉네임인 User를 조회하려고 한다고 할 때, flush가 되지 않았다면 데이터베이스에서는 kun2로 닉네임이 변경되지 않았을 것이다.
플러시 모드를 기본값인 AUTO로 사용한다면 쿼리 실행 직전에 영속성 컨텍스트가 플러시 되고 kun2 닉네임으로 User를 조회할 수 있게된다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
자바 ORM 표준 JPA 프로그래밍</p>
</blockquote>]]></content><author><name>kun</name></author><category term="jpa" /><summary type="html"><![CDATA[JPQL 벌크 연산 엔티티를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나, 삭제하려면 entityManger.remove() 메서드를 사용할 수 있다. 하지만 이 방법으로 수백 개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다. 이럴 때 여러 건을 한번에 수정하거나 삭제하는 벌크 연산을 사용할 수 있다.]]></summary></entry><entry><title type="html">JPQL과 페치 조인</title><link href="http://localhost:4000/jpa/JPQL%EA%B3%BC-%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B8/" rel="alternate" type="text/html" title="JPQL과 페치 조인" /><published>2022-07-15T00:00:00+09:00</published><updated>2022-07-15T00:00:00+09:00</updated><id>http://localhost:4000/jpa/JPQL%EA%B3%BC%20%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B8</id><content type="html" xml:base="http://localhost:4000/jpa/JPQL%EA%B3%BC-%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B8/"><![CDATA[<h2 id="jpql이란">JPQL이란</h2>
<p>JPQL(Java PErsistence Query Language)은 엔티티 객체를 조회하는 객체지향 쿼리다.
JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. 데이터베이스 방언을 변경하면 JPQL을 수정하지 않고도 데이터베이스를 변경할 수 있다. 왜냐하면 JPQL이 제공하는 표준화된 함수를 사용하면 선택한 방언에 따라 해당 데이터베이스에 맞춘 적절한 SQL 함수가 실행되기 때문이다.</p>

<p><br /></p>

<h2 id="jpql-페치-조인">JPQL 페치 조인</h2>
<p>일반적인 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위헤 제공하는 기능이다. 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능이다.</p>

<h3 id="엔티티-페치-조인">엔티티 페치 조인</h3>
<p>페치 조인을 사용해서 Question 엔티티를 조회하면서 연관된 User 엔티티도 함께 조회하는 JPQL을 보자.
<img src="https://velog.velcdn.com/images/hdg3052/post/9e112e18-59af-4c42-8878-00d8a84c68e0/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/1337de76-9a5f-4366-a3b2-00b86cb4c16b/image.png" alt="" /></p>

<p>SQL을 보면 Question 엔티티만 조회하였는데도 연관된 Useer 엔티티도 함께 조회된 것을 확인할 수 있다. 페치조인을 이용해서 조회한다면 User 엔티티는 프록시 객체가 아니라 실제 객체다.
<img src="https://velog.velcdn.com/images/hdg3052/post/b4a2131c-0b0d-4bc5-9fba-2b9715ac5dd7/image.png" alt="" /></p>

<p>Question과 User엔티티를 지연 로딩으로 설정했다고 가정을 하고, <code class="language-plaintext highlighter-rouge">entityManger.find</code>로 question을 조회하면 User객체는 프록시 객체다. 
<img src="https://velog.velcdn.com/images/hdg3052/post/38d0ed19-a5c1-4230-b3fc-99947c163682/image.png" alt="" /></p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
자바 ORM 표준 JPA 프로그래밍</p>
</blockquote>]]></content><author><name>kun</name></author><category term="jpa" /><summary type="html"><![CDATA[JPQL이란 JPQL(Java PErsistence Query Language)은 엔티티 객체를 조회하는 객체지향 쿼리다. JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. 데이터베이스 방언을 변경하면 JPQL을 수정하지 않고도 데이터베이스를 변경할 수 있다. 왜냐하면 JPQL이 제공하는 표준화된 함수를 사용하면 선택한 방언에 따라 해당 데이터베이스에 맞춘 적절한 SQL 함수가 실행되기 때문이다.]]></summary></entry><entry><title type="html">영속성 컨텍스트의 특징</title><link href="http://localhost:4000/jpa/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95/" rel="alternate" type="text/html" title="영속성 컨텍스트의 특징" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/jpa/%EC%98%81%EC%86%8D%EC%84%B1%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98%20%ED%8A%B9%EC%A7%95</id><content type="html" xml:base="http://localhost:4000/jpa/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95/"><![CDATA[<h2 id="1차-캐시">1차 캐시</h2>
<p>영속성 컨텍스트는 내부에 캐시를 가지고 있다.
쉽게 이야기해서 영속성 컨텍스트 내부에 엔티티를 보관하고 있는 Map이 하나 있다고 생각하면 된다.
1차 캐시의 키는 식별자 값인데, 식별자 값은 우리가 엔티티를 정의할 때 <code class="language-plaintext highlighter-rouge">@Id</code> 를 붙인 필드다.
따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.</p>

<h3 id="1차-캐시의-과정">1차 캐시의 과정</h3>
<ol>
  <li>조회할 때 1차 캐시에 해당 데이터가 있는지 탐색을 하고 존재하면 바로 가져온다.</li>
  <li>조회할 때 1차 캐시에 해당 데이터가 없으면 DB에 접근해 값을 가져온다.</li>
  <li>DB에서 값을 바로 가져오는 것이 아닌 다음 탐색에서 재사용할 수 있도록 1차 캐시에 보관한다.</li>
</ol>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/d2e460a2-e66f-4894-8c5a-5cc53afd3cde/image.png" alt="" /></p>

<p>User를 조회해오는 메서드인데, 1차 캐시가 적용되어 쿼리가 한번만 날라가는지 확인하기 위해 메서드 호출을 2번 해보았다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/562d5322-f932-47ea-9ad4-b51031ffd72e/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/6f76a9c8-a4cd-4761-84ba-67e3df36cdc7/image.png" alt="" /></p>

<p>테스트 코드를 실행했을 때, <code class="language-plaintext highlighter-rouge">findUser</code>메서드 내에서 <code class="language-plaintext highlighter-rouge">userRepository</code>의 <code class="language-plaintext highlighter-rouge">findById</code> 메서드가 2번 호출되었지만 1차 캐시가 적용되어 쿼리가 한번만 날라가는 것을 확인할 수 있다.
<code class="language-plaintext highlighter-rouge">findById</code>가 처음 호출 될때 1차 캐시에 데이터가 존재하지 않아 DB에 직접 접근하였고, 1차 캐시에 보관해놓았다. 그러므로 <code class="language-plaintext highlighter-rouge">findById</code>가 2번째 호출 될 때 DB에 직접 접근하지 않고도 영속성 컨텍스트의 1차 캐시에서 데이터를 바로 가져올 수 있었다.</p>

<h3 id="1차-캐시의-라이프-사이클">1차 캐시의 라이프 사이클</h3>
<p>1차 캐시는 한 트랜잭션 내에서만 공유되었다 사라지는 영역이다. 왜냐하면 엔티티 매니저는 트랜잭션 단위이이므로 트랜잭션이 종료되면 1차 캐시도 지워버린다.
그래서 1차 캐시가 실질적으로 성능에 큰 기여를 하는 것은 아니다.
어플리케이션 전체 영역에서 공유하는 캐시 공간은 2차 캐시다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/b9c86c77-12e3-46cc-8c4f-2609802d3c0c/image.png" alt="" /></p>

<p>트랜잭션이 종료될 때 1차 캐시도 지워지는지 확인해보기 위한 테스트다.
<code class="language-plaintext highlighter-rouge">findUser</code> 를 2번 호출해보았을 때, 쿼리가 몇번 날라가는지 확인해보겠다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/d65954ac-7d0b-4393-b5c7-ab5f35dd5596/image.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">findUser</code> 가 실행 완료될 때, 트랜잭션이 종료 되었기 때문에 1차 캐시는 비워지게 되었고 메서드를 호출한 수만큼 쿼리가 날라간 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="쓰기-지연">쓰기 지연</h2>
<p>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 영속성 컨텍스트 내부 쿼리 저장소에 SQL문을 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 쓰기 지연이라 한다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/d43a785a-bc11-4a31-a08b-5dfe8195b5fb/image.png" alt="" /></p>

<p>insert 쿼리문이 <code class="language-plaintext highlighter-rouge">save</code>가 호출될 때마다 실행되는지, 트랜잭션이 종료될 때 쿼리문이 실행되는지 확인하기 위한 테스트다.
<img src="https://velog.velcdn.com/images/hdg3052/post/30beb84b-b8ee-4919-b0c0-6f68e57f0f83/image.png" alt="" />
위와 같이 <code class="language-plaintext highlighter-rouge">save</code> 호출 시점이 아닌 트랜잭션 종료 시점에 쿼리문에 한번에 날라가는 것을 확인할 수 있다.</p>

<h3 id="쓰기-지연의-과정">쓰기 지연의 과정</h3>
<ol>
  <li>Question1을 영속화한다. 영속성 컨텍스트는 1차 캐시에 Question1을 저장하면서 동시에 insert 쿼리를 만든다. 그리고 insert 쿼리를 SQL 저장소에 보관한다.</li>
  <li>Question2를 영속화한다. 동일하게 영속성 컨텍스트에 Question2를 저장하고 insert 쿼리를 만들어서 SQL 저장소에 보관한다.</li>
  <li>트랜잭션이 커밋되기 이전에 엔티티 매니저는 영속성 컨텍스트를 flush 를 하게 되면서 SQL 저장소에 있는 쿼리들을 데이터베이스에 보낸다.</li>
  <li>실제 데이터베이스 트랜잭션을 커밋한다.</li>
</ol>

<p>만약 10개의 데이터를 저장한다고 할 때, 데이터베이스와 10번 통신할 것을 쓰기 지연 기능을 통해서 1번만 통신할 수 있게 해준다.</p>

<h3 id="쓰기-지연-적용이-안되는-경우">쓰기 지연 적용이 안되는 경우</h3>
<p>엔티티 키 전략이 Identity인 경우에는 엔티티 매니저를 영속화하는 즉시 엔티티를 데이터베이스에 flush 한다. 왜냐하면 영속성 컨텍스트에 저장하기 위해서는 데이터베이스 PK가 필수이기 때문이다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/6318004e-edab-416e-9c3d-82e5752ba820/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/2bd3561a-5ede-459c-8f99-a1d25635efd5/image.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">save</code>가 호출될 때마다 insert 쿼리가 날라가는 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="변경-감지">변경 감지</h2>
<p>JPA로 엔티티를 수정할 때는 단순히 엔티티를 변경하면 되면 update 쿼리가 날라간다. 이때 엔티티는 영속 상태인 엔티티에만 적용이된다. 이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지라 한다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/6bc18786-3eed-4040-95f5-187e55097fad/image.png" alt="" /></p>

<h3 id="변경-감지-과정">변경 감지 과정</h3>
<p>JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다. 그리고 flush 되는 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.</p>

<ol>
  <li>트랜잭션을 커밋하면 엔티티 매니저 내부에서 flush가 호출된다.</li>
  <li>엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.</li>
  <li>변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.</li>
  <li>쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.</li>
  <li>데이터베이스 트랜잭션을 커밋한다.</li>
</ol>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/fb50a3ea-e038-44b4-81d2-8adfd3456bd4/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/abeaed8d-4b38-4c70-b6fd-0c95dc24af9d/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/41e28a5f-4389-46b1-a137-53b6cb64612e/image.png" alt="" /></p>

<p>select 문으로 user를 조회해와서 조회된 user 객체는 영속성 컨텍스트에 존재하게 되었고, user의 이름을 변경하기만 했는데 트랜잭션이 커밋되고 update 쿼리가 날라가는 것을 확인할 수 있다.</p>

<h3 id="항상-update-쿼리가-똑같다">항상 update 쿼리가 똑같다?</h3>
<p>위의 update 쿼리를 보면 모든 필드를 수정하고 있다. 
이렇게 모든 필드를 사용하면 데이터 전송량이 증가하는 단점이 있지만, 수정 쿼리가 항상 같기 때문에 어플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있고 데이터베이스에서는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.</p>

<p>상황에 따라서 필드가 많거나 내용이 너무 크면 수정된 데이터만 사용해서 동적으로 UPDATE DQL을 생성하는 전략을 선택하면 된다.
적용하는 방법으로는 엔티티에 @DynamicUpdate 어노테이션을 붙여주면 된다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
자바 ORM 표준 JPA 프로그래밍</p>
</blockquote>]]></content><author><name>kun</name></author><category term="jpa" /><summary type="html"><![CDATA[1차 캐시 영속성 컨텍스트는 내부에 캐시를 가지고 있다. 쉽게 이야기해서 영속성 컨텍스트 내부에 엔티티를 보관하고 있는 Map이 하나 있다고 생각하면 된다. 1차 캐시의 키는 식별자 값인데, 식별자 값은 우리가 엔티티를 정의할 때 @Id 를 붙인 필드다. 따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.]]></summary></entry><entry><title type="html">스프링 빈</title><link href="http://localhost:4000/spring/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88/" rel="alternate" type="text/html" title="스프링 빈" /><published>2022-06-19T00:00:00+09:00</published><updated>2022-06-19T00:00:00+09:00</updated><id>http://localhost:4000/spring/%EC%8A%A4%ED%94%84%EB%A7%81%20%EB%B9%88</id><content type="html" xml:base="http://localhost:4000/spring/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88/"><![CDATA[<h3 id="스프링-빈">스프링 빈</h3>

<p>스프링 컨테이너에서 관리하는 자바 객체를 스프링 빈이라고 한다.
조금 더 자세하게 설명하자면, 기존에 Java 프로그램에서는 객체를 생성할 때 우리가 직접  <code class="language-plaintext highlighter-rouge">new 생성자</code>를 입력해 객체를 생성하였지만,  우리가 직접 객체를 생성하는 것이 아닌 Spring에 의해 생성되고 관리되는 자바 객체를 스프링 빈이라고 한다.</p>

<p>그럼 스프링 컨테이너에는 빈을 등록하는 방법들에 대해 알아보자.</p>

<p><br /></p>

<h3 id="스프링-빈-등록하기">스프링 빈 등록하기</h3>

<p>스프링 빈을 스프링 컨테이너에 등록하는 방법으로는 여러가지 방법들이 존재한다. 그 중 대표적으로 가장 자주 사용하는 자바 설정 파일을 이용하는 방법과 컴포넌트 스캔을 이용하는 방법에 대해 소개해보겠다.</p>

<p><br /></p>

<h4 id="자바-설정-파일">자바 설정 파일</h4>

<p>@Configuration과 @Bean 어노테이션을 이용하여 Bean을 등록하는 방법이다.
스프링 컨테이너는 @Configuration이 붙은 클래스를 설정 정보로 사용한다. 이 클래스에 정의된 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.</p>

<p><img width="672" alt="image" src="https://user-images.githubusercontent.com/67885363/176006223-03bc2618-4606-4676-8edc-96cfe2e629dd.png" /></p>

<ul>
  <li>스프링 컨테이서 생성 및 설정 파일 등록</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<p><img width="1140" alt="image" src="https://user-images.githubusercontent.com/67885363/176006750-315b21b5-34bb-4bbc-8c1a-637ce7a94f59.png" /></p>

<p>5개의 빈이 등록된 것을 확인할 수 있다.</p>

<p>빈 이름은 <code class="language-plaintext highlighter-rouge">@Bean(name="xxxxx")</code>와 같이 name 속성을 사용해서 직접 부여할수 있고 기본 값은 메서드 명을 사용한다.
빈 이름이 중복이 되면, 예외가 발생할수도 있고 중복된 빈이 무시될 수도 있다.</p>

<p><br /></p>

<h4 id="컴포넌트-스캔">컴포넌트 스캔</h4>

<p>어플리케이션이 커져 등록해야 할 스프링 빈이 많아지게 된다면, 자바 설정 파일에 일일히 등록하기 힘들 것이다. 그래서 스프링은 설정 정보 없이 자동으로 스프링 빈을 등록할 수 있는 컴포넌트 스캔이라는 기능을 제공한다. @ComponentScan 어노테이션은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다.</p>

<p><img width="698" alt="image" src="https://user-images.githubusercontent.com/67885363/176011611-4724bfb6-4e36-4a08-b80c-2884bbc9ce2b.png" /></p>

<p>스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다. 위 클래스의 빈 이름은 memberServiceImpl이 된다. 빈 이름을 직접 지정하기 위해서는  <code class="language-plaintext highlighter-rouge">@Component("xxxxx")</code>와 같이 지정할 수 있다.</p>

<p>@ComponentScan 어노테이션은 여러가지 속성들을 사용하여 스캔 옵션을 지정할 수 있다.</p>

<ul>
  <li>탐색 패키지 시작 지점 지정하기</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ComponentScan</span><span class="o">(</span>
        <span class="n">basePackages</span> <span class="o">=</span> <span class="s">"hello.core"</span>
<span class="o">)</span>
</code></pre></div></div>

<p>basePackages 는 탐색할 패키지의 시작 위치를 지정한다. 선언한 패키지를 포함해서 하위 패키지를 모두 탐색하고 basePackages를 여러 시작 위치를 지정할 수도 있다.</p>

<ul>
  <li>컴포넌스 스캔 대상 필터링하기</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@ComponentScan</span><span class="o">(</span>
            <span class="n">includeFilters</span> <span class="o">=</span> <span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">ANNOTATION</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">MyIncludeComponent</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
            <span class="n">excludeFilters</span> <span class="o">=</span> <span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">ANNOTATION</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">MyExcludeComponent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">)</span>
</code></pre></div></div>

<p>includeFilters는 탐색 지점부터 컴포넌트 스캔 대상에 존재하지 않은 파일을 추가로 지정할 수 있고 excludeFilters는 컴포넌트 스캔에서 제외할 대상을 지정한다.</p>

<p><br /></p>

<h3 id="자동-빈-등록-vs-수동-빈-등록">자동 빈 등록 vs 수동 빈 등록</h3>

<p>스프링 MVC의 @Controller, @Service, @Repository 어노테이션에도 @Component가 포함되어 있고, 우리는 자동 빈 등록을 한다.</p>

<p>그렇다면 수동 빈 등록은 언제 사용하면 좋을까?</p>

<p>어플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있는데 기술 지원 빈을 등록할 때 사용하면 좋을 것 같다.
일단 업무 로직 빈과 기술 지원 빈에 대해 알아보자.</p>

<ul>
  <li>업무 로직 빈 : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 레포지토리등이 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.</li>
  <li>기술 지원 빈 : 기술적인 문제나 공통 관심사를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.</li>
</ul>

<p>업무 로직은 숫자도 매우 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리 처럼 어느정도 유사한 패턴이 있다. 이런 경우 자동 기능을 적극 사용하는 것이 좋다. 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.</p>

<p>기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 보통 어플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 그리고 업무 로직은 문제가 발생했을 대 어디가 문제인지 잘 들어나지만, 기술 지원 로직은 적용이 잘되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다. 그래서 이런 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.</p>

<p>하지만 비즈니스 로직 중에서 다형성을 활용할 때는 자동 빈 등록보다 수동 빈 등록으로 하는 것이 가독성에 좋을 수도 있다.</p>

<p><br /></p>

<h3 id="빈-중복-등록">빈 중복 등록</h3>

<p>빈을 중복 등록되면 예외가 발생하는 경우도 있고 중복된 빈이 무시되는 경우도 존재하는데 세 가지 상황에 대해 살펴보자.</p>

<ul>
  <li>수동 빈 등록 vs 수동 빈 등록</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"memberService"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">DiscountPolicy</span> <span class="nf">discountPolicy</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">RateDiscountPolicy</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryMemberRepository</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>위 설정 파일을 컨테이너에 등록하면 어떻게 될까?</p>

<p><img width="1164" alt="image" src="https://user-images.githubusercontent.com/67885363/176017647-5ea68b63-a6f3-4180-a223-c4ab05e827a4.png" /></p>

<p>1번째, 2번째 빈의 이름이 memberService로 중복이 되었다. 예외는 발생하지 않고 둘 중 하나만 빈으로 등록이 되었다. 결과는2번째 선언한 빈이 무시가 되었다. memberService의 빈 타입을 출력해보니 첫번째 선언한 빈의 타입과 일치하다.</p>

<p>1번째와 2번째 메서드 순서를 바꿔보니 결과가 바뀌었다.<img width="1164" alt="image" src="https://user-images.githubusercontent.com/67885363/176018238-a226afd9-430c-47b3-9644-a590a011d9d9.png" /></p>

<p>수동 빈 등록을 할 때 빈 이름이 충돌하게 되면 가장 먼저 등록된 빈 이외에는 무시되는 것을 확인할 수 있다.</p>

<p><br /></p>

<ul>
  <li>자동 빈 등록 vs 자동 빈 등록</li>
</ul>

<p>컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록될 때, 이름이 같은 경우에 ConflictingBeanDefinitionException이 발생한다.</p>

<p><img width="1000" alt="image" src="https://user-images.githubusercontent.com/67885363/176019040-2849295c-0d0a-494d-8628-8edf37962966.png" /></p>

<p><br /></p>

<ul>
  <li>수동 빈 등록 vs 자동 빈 등록</li>
</ul>

<p>이 경우에는 수동 빈 등록이 우선권을 가진다. 수동 빈 등록이 자동 빈을 오버라이딩 해버린다.</p>

<p><img width="1000" alt="image" src="https://user-images.githubusercontent.com/67885363/176020449-6b6471ad-854b-4d5e-8d31-e56619d1ff75.png" /></p>

<p>개발자가 의도적으로 이런 결과를 기대한 것이라면 좋지만 보통 여러 설정들이 꼬여서 이런 결과가 만들어진다고 한다. 예외가 발생하지 않는 예외상황은 정말 잡기 어려운 버그가 된다. 그래서 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 변경했다고 한다.</p>

<p>만약 수동 빈 등록이 자동 빈 등록을 오버라이딩하는 것을 허용하게 설정을 바꾸고 싶다면 application.properties에서 <code class="language-plaintext highlighter-rouge">spring.main.allow-bean-definition-overriding=true</code>을 작성하면 된다.</p>

<p><br /><br /></p>

<h3 id="빈-생명주기-콜백">빈 생명주기 콜백</h3>

<p>스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.
따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.
그런데 개발자가 의존관계 주입이 모두 완료된 시점을 알 수 없으니, 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 컨테이너가 종료되기 직전에 소멸 콜백을 준다.</p>

<p><strong>스프링 빈의 이벤트 라이프 사이클</strong></p>

<ul>
  <li>스프링 컨테이너 생성</li>
  <li>스프링 빈 생성</li>
  <li>의존관계 주입</li>
  <li>초기화 콜백</li>
  <li>사용</li>
  <li>소멸전 콜백</li>
  <li>스프링 종료</li>
</ul>

<h4 id="스프링이-지원하는-빈-생명주기-콜백-방법-3가지">스프링이 지원하는 빈 생명주기 콜백 방법 3가지</h4>

<p><strong>InitializingBean, DisposableBean</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkClient</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span><span class="o">,</span> <span class="nc">DisposableBean</span> <span class="o">{</span>
    <span class="o">...</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">connect</span><span class="o">();</span>
        <span class="n">call</span><span class="o">(</span><span class="s">"초기화 메시지"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">disconnect</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>스프링 전용 인터페이스이므로 스프링에 의존적이다.</li>
  <li>코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.</li>
</ul>

<p><br /></p>

<p><strong>설정 정보에 빈 등록시 초기화 메서드, 종료 메서드 지정</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Configuration</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">LifeCycleConfig</span> <span class="o">{</span>

        <span class="nd">@Bean</span><span class="o">(</span><span class="n">initMethod</span> <span class="o">=</span> <span class="s">"init"</span><span class="o">,</span> <span class="n">destroyMethod</span> <span class="o">=</span> <span class="s">"close"</span><span class="o">)</span>
        <span class="kd">public</span> <span class="nc">NetworkClient</span> <span class="nf">networkClient</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">NetworkClient</span> <span class="n">networkClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NetworkClient</span><span class="o">();</span>
            <span class="n">networkClient</span><span class="o">.</span><span class="na">setUrl</span><span class="o">(</span><span class="s">"http://hello-spring.dev"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">networkClient</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkClient</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">connect</span><span class="o">();</span>
        <span class="n">call</span><span class="o">(</span><span class="s">"초기화 메시지"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">disconnect</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>@Bean의 destoryMethod 속성에는 메서드 추론 기능이 있다. 라이브러리에서는 대부분 close, shutdown이라는 종료 메서드를 사용한다.
추론 기능은 @Bean에 destoryMethod를 명시하지 않아도 close, shutdown라는 이름의 메서드를 자동으로 호출해준다.</p>

<p>추론 기능을 사용하기 싫으면 detstoryMethod=”“처럼 빈 공백을 지정하면 된다.</p>

<p><br /></p>

<p><strong>@PostConstruct, PreDestroy 어노테이션 지원</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkClient</span> <span class="o">{</span>
	 <span class="nd">@PostConstruct</span>
	 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">connect</span><span class="o">();</span>
	    <span class="n">call</span><span class="o">(</span><span class="s">"초기화 연결 메시지"</span><span class="o">);</span>
	 <span class="o">}</span>
	 
   <span class="nd">@PreDestroy</span>
	 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
     <span class="n">disConnect</span><span class="o">();</span>
	 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 어노테이션들의 패키지를 잘 보면 javax.annotation이다.
스프링에 종속적인 기술이 아니라 JSR-250 라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.</p>

<p>또한 어노테이션 하나만 붙이면 되므로 매우 편리하다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)
토비의 스프링 - vol.1 (이일민 님)</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><summary type="html"><![CDATA[스프링 빈]]></summary></entry><entry><title type="html">MVC 구조</title><link href="http://localhost:4000/spring/MVC-%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="MVC 구조" /><published>2022-06-18T00:00:00+09:00</published><updated>2022-06-18T00:00:00+09:00</updated><id>http://localhost:4000/spring/MVC%20%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="http://localhost:4000/spring/MVC-%EA%B5%AC%EC%A1%B0/"><![CDATA[<h2 id="mvc-구조">MVC 구조</h2>

<p><img width="1020" alt="image" src="https://user-images.githubusercontent.com/67885363/174560490-4ac6fccf-7325-4db4-8f71-4c32cfb2672a.png" /></p>

<h3 id="동작-순서">동작 순서</h3>

<ol>
  <li>DispatcherServlet으로 클라이언트의 웹 요청이 들어온다.</li>
  <li>웹 요청을 핸들러 매핑에 위임해 요청 URL에 매핑된 핸들러를 조회한다.</li>
  <li>핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.</li>
  <li>핸들러 어댑터가 실행되고 핸들러 어댑터가 핸들러를 실행시킨다. 이때 핸들러가 반환한 정보를 핸들러 어댑터가 ModelAndView로 변환해서 반환한다.</li>
  <li>뷰 리졸버가 뷰 이름을 전달받아 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.</li>
  <li>DispatcherServlet은 View에게 Model을 전달하고 화면 표시를 요청한다. 이때, Model이 null이면 View를 그대로 사용하고 Model 값이 있으면 View에 Model 데이터를 렌더링한다.</li>
  <li>DispatcherServlet은 View 결과를 클라이언트에게 반환한다.</li>
</ol>

<p><br />
<br /></p>

<h3 id="프론트-컨트롤러-패턴과-dispatcherservlet">프론트 컨트롤러 패턴과 DispatcherServlet</h3>

<p>DispatcherServlet을 설명하기 전에 프론트 컨트롤러 패턴에 대해 알아보자.
프론트 컨트롤러 패턴이란 모든 요청을 받는 서블릿을 하나로 두고, 서블릿이 요청에 맞는 컨트롤러를 호출해서 처리해주는 것이다.
프론트 컨트롤러 패턴을 도입하면, 컨트롤러를 구현할 때 직접 서블릿을 다루지 않아도 되고, 공통된 로직을 줄임으로써 개발자는 핵심 로직에만 집중할 수 있다.</p>

<ul>
  <li>프론트 컨트롤러 도입 전</li>
</ul>

<p><img width="670" alt="image" src="https://user-images.githubusercontent.com/67885363/175099647-94d7a9d8-bced-4f97-8acb-f32b56e98ac7.png" /></p>

<ul>
  <li>프론트 컨트롤러 도입 후</li>
</ul>

<p><img width="670" alt="image" src="https://user-images.githubusercontent.com/67885363/175099833-c2640c9d-4dc0-42e3-8168-198874b41bed.png" /></p>

<p>우리가 스프링을 이용해 개발을 해오면서 컨트롤러 로직을 작성할 때, 서블릿을 직접 다룬 적이 없었던 이유도 Spring web mvc가 프론트 컨트롤러 패턴을 사용하고 있기 때문이다.</p>

<p>클라이언트로부터 요청이 들어오면 서블릿 컨테이너가 해당하는 서블릿을 실행시키는데 이 때 실행되는 서블릿이 Dispatcher Servlet이다. 공통 작업은 DispatcherServlet에서 처리하고, 이외의 작업은 적절한 세부 컨트롤러를 호출하여 처리한다.</p>

<p><br />
<br /></p>

<h3 id="스프링-mvc-동작방식">스프링 MVC 동작방식</h3>

<p>DispatcherServlet은 FrameworkServlet.java &gt; HttpServlet.java &gt; Servlet.java 를 상속받아 구현한 서블릿으로 Servlet Container에서 들어오는 모든 요청을 먼저 받아 중앙 집중식으로 처리해주는 프론트 컨트롤러다.</p>

<p>DispatcherServlet은 웹 요청에 따른 처리를 해주기 위해 처음으로 <code class="language-plaintext highlighter-rouge">doService()</code>메서드를 호출한다.</p>

<p><img width="854" alt="image" src="https://user-images.githubusercontent.com/67885363/175106591-22c95a30-4ec2-4a8d-adaf-60912ff66c56.png" /></p>

<p>그리고 DispatcherServlet의 핵심인 <code class="language-plaintext highlighter-rouge">doDispatch()</code> 메서드를 호출한다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doDispatch</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span>
            <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">HttpServletRequest</span> <span class="n">processedRequest</span> <span class="o">=</span> <span class="n">request</span><span class="o">;</span>
        <span class="nc">HandlerExecutionChain</span> <span class="n">mappedHandler</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ModelAndView</span> <span class="n">mv</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

		<span class="c1">// 1. 핸들러 조회</span>
        <span class="n">mappedHandler</span> <span class="o">=</span> <span class="n">getHandler</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mappedHandler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">noHandlerFound</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

		<span class="c1">//2.핸들러 어댑터 조회-핸들러를 처리할 수 있는 어댑터</span>
        <span class="nc">HandlerAdapter</span> <span class="n">ha</span> <span class="o">=</span> <span class="n">getHandlerAdapter</span><span class="o">(</span><span class="n">mappedHandler</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>

		<span class="c1">// 3. 핸들러 어댑터 실행 -&gt; 4. 핸들러 어댑터를 통해 핸들러 실행 -&gt; 5. ModelAndView 반환 </span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">ha</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">mappedHandler</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>

        <span class="n">processDispatchResult</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">mappedHandler</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span>
                <span class="n">dispatchException</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processDispatchResult</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                                       <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HandlerExecutionChain</span> <span class="n">mappedHandler</span><span class="o">,</span> <span class="nc">ModelAndView</span>
                                               <span class="n">mv</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="c1">// 뷰 렌더링 호출</span>
        <span class="n">render</span><span class="o">(</span><span class="n">mv</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">(</span><span class="nc">ModelAndView</span> <span class="n">mv</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                          <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">View</span> <span class="n">view</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">viewName</span> <span class="o">=</span> <span class="n">mv</span><span class="o">.</span><span class="na">getViewName</span><span class="o">();</span>

        <span class="c1">//6. 뷰 리졸버를 통해서 뷰 찾기,7.View 반환</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">resolveViewName</span><span class="o">(</span><span class="n">viewName</span><span class="o">,</span> <span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">locale</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>

		<span class="c1">// 8. 뷰 렌더링</span>
        <span class="n">view</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>먼저 웹 요청을 처리할 수 있는 핸들러를 찾기 위해 <code class="language-plaintext highlighter-rouge">getHandler()</code> 메서드를 호출한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Nullable</span>
	<span class="kd">protected</span> <span class="nc">HandlerExecutionChain</span> <span class="nf">getHandler</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">handlerMappings</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">HandlerMapping</span> <span class="n">mapping</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">handlerMappings</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">HandlerExecutionChain</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="na">getHandler</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">handler</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">handler</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>핸들러 매핑을 순서대로 실행해서, 핸들러를 찾는다.</p>

<blockquote>
  <p>0 = RequestMappingHandlerMapping : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
<br /> 1 = BeanNameUrlHandlerMapping : URL과 일치하는 이름을 갖는 스프링 빈의 이름으로 핸들러를 찾는다.
<br /> 2 = ControllerBeanNameHandlerMapping : URL과 일치하는 이름을 갖는 스프링 빈의 아이디로 핸들러를 찾는다.</p>
</blockquote>

<p>핸들러 매핑으로 HandlerExecutionChain을 결정하는데 HandlerExecutionChain 구현체는 실제로 호출된 핸들러에 대한 참조를 가지고 있다. 즉 무엇이 실행되어야 될지 알고 있는 객체라고 말할 수 있다.</p>

<p>HandlerExecutionChian이 발견되지 않아 null을 반환하면 404 Not Found를 전달하고, 발견되면 HandlerAdapter 결정하러간다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kd">protected</span> <span class="nc">HandlerAdapter</span> <span class="nf">getHandlerAdapter</span><span class="o">(</span><span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">handlerAdapters</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">HandlerAdapter</span> <span class="n">adapter</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">handlerAdapters</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">adapter</span><span class="o">.</span><span class="na">supports</span><span class="o">(</span><span class="n">handler</span><span class="o">))</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">adapter</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">ServletException</span><span class="o">(</span><span class="s">"No adapter for handler ["</span> <span class="o">+</span> <span class="n">handler</span> <span class="o">+</span>
				<span class="s">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>찾은 핸들러를 실행하기 위해 해당 핸들러를 맞는 핸들러 어댑터를 탐색해야 한다. 이를 위해 <code class="language-plaintext highlighter-rouge">getHandlerAdapter()</code>메서드를 호출한다. 핸들러 어댑터도 순서대로 <code class="language-plaintext highlighter-rouge">supports()</code>메서드를 실행해서 찾는다.</p>

<blockquote>
  <p>0 = RequestMappingHandlerAdapter : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
<br /> 1 = HttpRequestHandlerAdapter : HttpRequestHandler 처리
<br /> 2 = SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">mv</span> <span class="o">=</span> <span class="n">ha</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">mappedHandler</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>
</code></pre></div></div>

<p>핸들러 어댑터를 이용하여  <code class="language-plaintext highlighter-rouge">handle()</code>메서드로 핸들러의 메서드를 실행하고 그 결과로 ModelAndView를 반환한다.</p>

<p><br /></p>

<p>핸들러가 작업을 마치고 정보를 ModelAndView 타입 오브젝트에 담아서 DispatcherServlet에 돌려주는 방법은 크게 두 가지다. 하나는 View 타입의 오브젝트를 돌려주는 방법이고, 다른 하나는 뷰 이름을 돌려주는 방법이다. 뷰 이름을 돌려주는 경우에는 실제 사용할 뷰를 결정해주는 뷰 리졸버가 필요하다.</p>

<p>다음으로 <code class="language-plaintext highlighter-rouge">processDispatchResult()</code>메서드가 호출된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processDispatchResult</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                                       <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HandlerExecutionChain</span> <span class="n">mappedHandler</span><span class="o">,</span> <span class="nc">ModelAndView</span>
                                               <span class="n">mv</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">render</span><span class="o">(</span><span class="n">mv</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">processDispatchResult()</code>메서드는  <code class="language-plaintext highlighter-rouge">render()</code>메서드를 호출한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">(</span><span class="nc">ModelAndView</span> <span class="n">mv</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                          <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">View</span> <span class="n">view</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">viewName</span> <span class="o">=</span> <span class="n">mv</span><span class="o">.</span><span class="na">getViewName</span><span class="o">();</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">resolveViewName</span><span class="o">(</span><span class="n">viewName</span><span class="o">,</span> <span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">locale</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>

        <span class="n">view</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">render()</code>는 View의 논리 이름을 물리 이름으로 변환시키기 위해 <code class="language-plaintext highlighter-rouge">resolveViewName()</code>메서드를 호출한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Nullable</span>
	<span class="kd">protected</span> <span class="nc">View</span> <span class="nf">resolveViewName</span><span class="o">(</span><span class="nc">String</span> <span class="n">viewName</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">model</span><span class="o">,</span>
			<span class="nc">Locale</span> <span class="n">locale</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">ViewResolver</span> <span class="n">viewResolver</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">View</span> <span class="n">view</span> <span class="o">=</span> <span class="n">viewResolver</span><span class="o">.</span><span class="na">resolveViewName</span><span class="o">(</span><span class="n">viewName</span><span class="o">,</span> <span class="n">locale</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">view</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">view</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>뷰 리졸버의 여러 구현체의 <code class="language-plaintext highlighter-rouge">resolveViewName()</code> 메서드를 호출하여 View의 논리 이름을 물리 이름으로 변환시킨다.</p>

<blockquote>
  <p>1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. (예: 엑셀 파일 생성 기능에 사용)
<br /> 2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.</p>
</blockquote>

<p>스프링 부트는 InternalResourceViewResolver 뷰 리졸버를 자동으로 등록하는데, 이때 application.properties 에 등록한 spring.mvc.view.prefix , spring.mvc.view.suffix 설정 정보를 사용해서 등록한다.</p>

<p>마지막으로, View 객체의 <code class="language-plaintext highlighter-rouge">render()</code> 메소드를 호출하여 View에 Model 데이터를 렌더링한다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)
토비의 스프링 - vol.1 (이일민 님)</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><summary type="html"><![CDATA[MVC 구조]]></summary></entry></feed>