<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-24T02:49:09+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Keep Going</title><author><name>kun</name></author><entry><title type="html">영속성 컨텍스트의 특징</title><link href="http://localhost:4000/jpa/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95/" rel="alternate" type="text/html" title="영속성 컨텍스트의 특징" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/jpa/%EC%98%81%EC%86%8D%EC%84%B1%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98%20%ED%8A%B9%EC%A7%95</id><content type="html" xml:base="http://localhost:4000/jpa/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95/"><![CDATA[<h2 id="1차-캐시">1차 캐시</h2>
<p>영속성 컨텍스트는 내부에 캐시를 가지고 있다.
쉽게 이야기해서 영속성 컨텍스트 내부에 엔티티를 보관하고 있는 Map이 하나 있다고 생각하면 된다.
1차 캐시의 키는 식별자 값인데, 식별자 값은 우리가 엔티티를 정의할 때 <code class="language-plaintext highlighter-rouge">@Id</code> 를 붙인 필드다.
따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.</p>

<h3 id="1차-캐시의-과정">1차 캐시의 과정</h3>
<ol>
  <li>조회할 때 1차 캐시에 해당 데이터가 있는지 탐색을 하고 존재하면 바로 가져온다.</li>
  <li>조회할 때 1차 캐시에 해당 데이터가 없으면 DB에 접근해 값을 가져온다.</li>
  <li>DB에서 값을 바로 가져오는 것이 아닌 다음 탐색에서 재사용할 수 있도록 1차 캐시에 보관한다.</li>
</ol>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/d2e460a2-e66f-4894-8c5a-5cc53afd3cde/image.png" alt="" /></p>

<p>User를 조회해오는 메서드인데, 1차 캐시가 적용되어 쿼리가 한번만 날라가는지 확인하기 위해 메서드 호출을 2번 해보았다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/562d5322-f932-47ea-9ad4-b51031ffd72e/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/6f76a9c8-a4cd-4761-84ba-67e3df36cdc7/image.png" alt="" /></p>

<p>테스트 코드를 실행했을 때, <code class="language-plaintext highlighter-rouge">findUser</code>메서드 내에서 <code class="language-plaintext highlighter-rouge">userRepository</code>의 <code class="language-plaintext highlighter-rouge">findById</code> 메서드가 2번 호출되었지만 1차 캐시가 적용되어 쿼리가 한번만 날라가는 것을 확인할 수 있다.
<code class="language-plaintext highlighter-rouge">findById</code>가 처음 호출 될때 1차 캐시에 데이터가 존재하지 않아 DB에 직접 접근하였고, 1차 캐시에 보관해놓았다. 그러므로 <code class="language-plaintext highlighter-rouge">findById</code>가 2번째 호출 될 때 DB에 직접 접근하지 않고도 영속성 컨텍스트의 1차 캐시에서 데이터를 바로 가져올 수 있었다.</p>

<h3 id="1차-캐시의-라이프-사이클">1차 캐시의 라이프 사이클</h3>
<p>1차 캐시는 한 트랜잭션 내에서만 공유되었다 사라지는 영역이다. 왜냐하면 엔티티 매니저는 트랜잭션 단위이이므로 트랜잭션이 종료되면 1차 캐시도 지워버린다.
그래서 1차 캐시가 실질적으로 성능에 큰 기여를 하는 것은 아니다.
어플리케이션 전체 영역에서 공유하는 캐시 공간은 2차 캐시다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/b9c86c77-12e3-46cc-8c4f-2609802d3c0c/image.png" alt="" /></p>

<p>트랜잭션이 종료될 때 1차 캐시도 지워지는지 확인해보기 위한 테스트다.
<code class="language-plaintext highlighter-rouge">findUser</code> 를 2번 호출해보았을 때, 쿼리가 몇번 날라가는지 확인해보겠다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/d65954ac-7d0b-4393-b5c7-ab5f35dd5596/image.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">findUser</code> 가 실행 완료될 때, 트랜잭션이 종료 되었기 때문에 1차 캐시는 비워지게 되었고 메서드를 호출한 수만큼 쿼리가 날라간 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="쓰기-지연">쓰기 지연</h2>
<p>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 영속성 컨텍스트 내부 쿼리 저장소에 SQL문을 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 쓰기 지연이라 한다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/d43a785a-bc11-4a31-a08b-5dfe8195b5fb/image.png" alt="" /></p>

<p>insert 쿼리문이 <code class="language-plaintext highlighter-rouge">save</code>가 호출될 때마다 실행되는지, 트랜잭션이 종료될 때 쿼리문이 실행되는지 확인하기 위한 테스트다.
<img src="https://velog.velcdn.com/images/hdg3052/post/30beb84b-b8ee-4919-b0c0-6f68e57f0f83/image.png" alt="" />
위와 같이 <code class="language-plaintext highlighter-rouge">save</code> 호출 시점이 아닌 트랜잭션 종료 시점에 쿼리문에 한번에 날라가는 것을 확인할 수 있다.</p>

<h3 id="쓰기-지연의-과정">쓰기 지연의 과정</h3>
<ol>
  <li>Question1을 영속화한다. 영속성 컨텍스트는 1차 캐시에 Question1을 저장하면서 동시에 insert 쿼리를 만든다. 그리고 insert 쿼리를 SQL 저장소에 보관한다.</li>
  <li>Question2를 영속화한다. 동일하게 영속성 컨텍스트에 Question2를 저장하고 insert 쿼리를 만들어서 SQL 저장소에 보관한다.</li>
  <li>트랜잭션이 커밋되기 이전에 엔티티 매니저는 영속성 컨텍스트를 flush 를 하게 되면서 SQL 저장소에 있는 쿼리들을 데이터베이스에 보낸다.</li>
  <li>실제 데이터베이스 트랜잭션을 커밋한다.</li>
</ol>

<p>만약 10개의 데이터를 저장한다고 할 때, 데이터베이스와 10번 통신할 것을 쓰기 지연 기능을 통해서 1번만 통신할 수 있게 해준다.</p>

<h3 id="쓰기-지연-적용이-안되는-경우">쓰기 지연 적용이 안되는 경우</h3>
<p>엔티티 키 전략이 Identity인 경우에는 엔티티 매니저를 영속화하는 즉시 엔티티를 데이터베이스에 flush 한다. 왜냐하면 영속성 컨텍스트에 저장하기 위해서는 데이터베이스 PK가 필수이기 때문이다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/6318004e-edab-416e-9c3d-82e5752ba820/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/2bd3561a-5ede-459c-8f99-a1d25635efd5/image.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">save</code>가 호출될 때마다 insert 쿼리가 날라가는 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="변경-감지">변경 감지</h2>
<p>JPA로 엔티티를 수정할 때는 단순히 엔티티를 변경하면 되면 update 쿼리가 날라간다. 이때 엔티티는 영속 상태인 엔티티에만 적용이된다. 이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지라 한다.</p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/6bc18786-3eed-4040-95f5-187e55097fad/image.png" alt="" /></p>

<h3 id="변경-감지-과정">변경 감지 과정</h3>
<p>JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다. 그리고 flush 되는 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.</p>

<ol>
  <li>트랜잭션을 커밋하면 엔티티 매니저 내부에서 flush가 호출된다.</li>
  <li>엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.</li>
  <li>변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.</li>
  <li>쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.</li>
  <li>데이터베이스 트랜잭션을 커밋한다.</li>
</ol>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/fb50a3ea-e038-44b4-81d2-8adfd3456bd4/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/abeaed8d-4b38-4c70-b6fd-0c95dc24af9d/image.png" alt="" /></p>

<p><img src="https://velog.velcdn.com/images/hdg3052/post/41e28a5f-4389-46b1-a137-53b6cb64612e/image.png" alt="" /></p>

<p>select 문으로 user를 조회해와서 조회된 user 객체는 영속성 컨텍스트에 존재하게 되었고, user의 이름을 변경하기만 했는데 트랜잭션이 커밋되고 update 쿼리가 날라가는 것을 확인할 수 있다.</p>

<h3 id="항상-update-쿼리가-똑같다">항상 update 쿼리가 똑같다?</h3>
<p>위의 update 쿼리를 보면 모든 필드를 수정하고 있다. 
이렇게 모든 필드를 사용하면 데이터 전송량이 증가하는 단점이 있지만, 수정 쿼리가 항상 같기 때문에 어플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있고 데이터베이스에서는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.</p>

<p>상황에 따라서 필드가 많거나 내용이 너무 크면 수정된 데이터만 사용해서 동적으로 UPDATE DQL을 생성하는 전략을 선택하면 된다.
적용하는 방법으로는 엔티티에 @DynamicUpdate 어노테이션을 붙여주면 된다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
자바 ORM 표준 JPA 프로그래밍</p>
</blockquote>]]></content><author><name>kun</name></author><category term="jpa" /><summary type="html"><![CDATA[1차 캐시 영속성 컨텍스트는 내부에 캐시를 가지고 있다. 쉽게 이야기해서 영속성 컨텍스트 내부에 엔티티를 보관하고 있는 Map이 하나 있다고 생각하면 된다. 1차 캐시의 키는 식별자 값인데, 식별자 값은 우리가 엔티티를 정의할 때 @Id 를 붙인 필드다. 따라서 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.]]></summary></entry><entry><title type="html">스프링 빈</title><link href="http://localhost:4000/spring/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88/" rel="alternate" type="text/html" title="스프링 빈" /><published>2022-06-19T00:00:00+09:00</published><updated>2022-06-19T00:00:00+09:00</updated><id>http://localhost:4000/spring/%EC%8A%A4%ED%94%84%EB%A7%81%20%EB%B9%88</id><content type="html" xml:base="http://localhost:4000/spring/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88/"><![CDATA[<h3 id="스프링-빈">스프링 빈</h3>

<p>스프링 컨테이너에서 관리하는 자바 객체를 스프링 빈이라고 한다.
조금 더 자세하게 설명하자면, 기존에 Java 프로그램에서는 객체를 생성할 때 우리가 직접  <code class="language-plaintext highlighter-rouge">new 생성자</code>를 입력해 객체를 생성하였지만,  우리가 직접 객체를 생성하는 것이 아닌 Spring에 의해 생성되고 관리되는 자바 객체를 스프링 빈이라고 한다.</p>

<p>그럼 스프링 컨테이너에는 빈을 등록하는 방법들에 대해 알아보자.</p>

<p><br /></p>

<h3 id="스프링-빈-등록하기">스프링 빈 등록하기</h3>

<p>스프링 빈을 스프링 컨테이너에 등록하는 방법으로는 여러가지 방법들이 존재한다. 그 중 대표적으로 가장 자주 사용하는 자바 설정 파일을 이용하는 방법과 컴포넌트 스캔을 이용하는 방법에 대해 소개해보겠다.</p>

<p><br /></p>

<h4 id="자바-설정-파일">자바 설정 파일</h4>

<p>@Configuration과 @Bean 어노테이션을 이용하여 Bean을 등록하는 방법이다.
스프링 컨테이너는 @Configuration이 붙은 클래스를 설정 정보로 사용한다. 이 클래스에 정의된 @Bean이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.</p>

<p><img width="672" alt="image" src="https://user-images.githubusercontent.com/67885363/176006223-03bc2618-4606-4676-8edc-96cfe2e629dd.png" /></p>

<ul>
  <li>스프링 컨테이서 생성 및 설정 파일 등록</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<p><img width="1140" alt="image" src="https://user-images.githubusercontent.com/67885363/176006750-315b21b5-34bb-4bbc-8c1a-637ce7a94f59.png" /></p>

<p>5개의 빈이 등록된 것을 확인할 수 있다.</p>

<p>빈 이름은 <code class="language-plaintext highlighter-rouge">@Bean(name="xxxxx")</code>와 같이 name 속성을 사용해서 직접 부여할수 있고 기본 값은 메서드 명을 사용한다.
빈 이름이 중복이 되면, 예외가 발생할수도 있고 중복된 빈이 무시될 수도 있다.</p>

<p><br /></p>

<h4 id="컴포넌트-스캔">컴포넌트 스캔</h4>

<p>어플리케이션이 커져 등록해야 할 스프링 빈이 많아지게 된다면, 자바 설정 파일에 일일히 등록하기 힘들 것이다. 그래서 스프링은 설정 정보 없이 자동으로 스프링 빈을 등록할 수 있는 컴포넌트 스캔이라는 기능을 제공한다. @ComponentScan 어노테이션은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다.</p>

<p><img width="698" alt="image" src="https://user-images.githubusercontent.com/67885363/176011611-4724bfb6-4e36-4a08-b80c-2884bbc9ce2b.png" /></p>

<p>스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다. 위 클래스의 빈 이름은 memberServiceImpl이 된다. 빈 이름을 직접 지정하기 위해서는  <code class="language-plaintext highlighter-rouge">@Component("xxxxx")</code>와 같이 지정할 수 있다.</p>

<p>@ComponentScan 어노테이션은 여러가지 속성들을 사용하여 스캔 옵션을 지정할 수 있다.</p>

<ul>
  <li>탐색 패키지 시작 지점 지정하기</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ComponentScan</span><span class="o">(</span>
        <span class="n">basePackages</span> <span class="o">=</span> <span class="s">"hello.core"</span>
<span class="o">)</span>
</code></pre></div></div>

<p>basePackages 는 탐색할 패키지의 시작 위치를 지정한다. 선언한 패키지를 포함해서 하위 패키지를 모두 탐색하고 basePackages를 여러 시작 위치를 지정할 수도 있다.</p>

<ul>
  <li>컴포넌스 스캔 대상 필터링하기</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@ComponentScan</span><span class="o">(</span>
            <span class="n">includeFilters</span> <span class="o">=</span> <span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">ANNOTATION</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">MyIncludeComponent</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
            <span class="n">excludeFilters</span> <span class="o">=</span> <span class="nd">@Filter</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="nc">FilterType</span><span class="o">.</span><span class="na">ANNOTATION</span><span class="o">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="nc">MyExcludeComponent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">)</span>
</code></pre></div></div>

<p>includeFilters는 탐색 지점부터 컴포넌트 스캔 대상에 존재하지 않은 파일을 추가로 지정할 수 있고 excludeFilters는 컴포넌트 스캔에서 제외할 대상을 지정한다.</p>

<p><br /></p>

<h3 id="자동-빈-등록-vs-수동-빈-등록">자동 빈 등록 vs 수동 빈 등록</h3>

<p>스프링 MVC의 @Controller, @Service, @Repository 어노테이션에도 @Component가 포함되어 있고, 우리는 자동 빈 등록을 한다.</p>

<p>그렇다면 수동 빈 등록은 언제 사용하면 좋을까?</p>

<p>어플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있는데 기술 지원 빈을 등록할 때 사용하면 좋을 것 같다.
일단 업무 로직 빈과 기술 지원 빈에 대해 알아보자.</p>

<ul>
  <li>업무 로직 빈 : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 레포지토리등이 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.</li>
  <li>기술 지원 빈 : 기술적인 문제나 공통 관심사를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그 처리 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.</li>
</ul>

<p>업무 로직은 숫자도 매우 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리 처럼 어느정도 유사한 패턴이 있다. 이런 경우 자동 기능을 적극 사용하는 것이 좋다. 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.</p>

<p>기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 보통 어플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 그리고 업무 로직은 문제가 발생했을 대 어디가 문제인지 잘 들어나지만, 기술 지원 로직은 적용이 잘되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다. 그래서 이런 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.</p>

<p>하지만 비즈니스 로직 중에서 다형성을 활용할 때는 자동 빈 등록보다 수동 빈 등록으로 하는 것이 가독성에 좋을 수도 있다.</p>

<p><br /></p>

<h3 id="빈-중복-등록">빈 중복 등록</h3>

<p>빈을 중복 등록되면 예외가 발생하는 경우도 있고 중복된 빈이 무시되는 경우도 존재하는데 세 가지 상황에 대해 살펴보자.</p>

<ul>
  <li>수동 빈 등록 vs 수동 빈 등록</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"memberService"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">DiscountPolicy</span> <span class="nf">discountPolicy</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">RateDiscountPolicy</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberServiceImpl</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryMemberRepository</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>위 설정 파일을 컨테이너에 등록하면 어떻게 될까?</p>

<p><img width="1164" alt="image" src="https://user-images.githubusercontent.com/67885363/176017647-5ea68b63-a6f3-4180-a223-c4ab05e827a4.png" /></p>

<p>1번째, 2번째 빈의 이름이 memberService로 중복이 되었다. 예외는 발생하지 않고 둘 중 하나만 빈으로 등록이 되었다. 결과는2번째 선언한 빈이 무시가 되었다. memberService의 빈 타입을 출력해보니 첫번째 선언한 빈의 타입과 일치하다.</p>

<p>1번째와 2번째 메서드 순서를 바꿔보니 결과가 바뀌었다.<img width="1164" alt="image" src="https://user-images.githubusercontent.com/67885363/176018238-a226afd9-430c-47b3-9644-a590a011d9d9.png" /></p>

<p>수동 빈 등록을 할 때 빈 이름이 충돌하게 되면 가장 먼저 등록된 빈 이외에는 무시되는 것을 확인할 수 있다.</p>

<p><br /></p>

<ul>
  <li>자동 빈 등록 vs 자동 빈 등록</li>
</ul>

<p>컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록될 때, 이름이 같은 경우에 ConflictingBeanDefinitionException이 발생한다.</p>

<p><img width="1000" alt="image" src="https://user-images.githubusercontent.com/67885363/176019040-2849295c-0d0a-494d-8628-8edf37962966.png" /></p>

<p><br /></p>

<ul>
  <li>수동 빈 등록 vs 자동 빈 등록</li>
</ul>

<p>이 경우에는 수동 빈 등록이 우선권을 가진다. 수동 빈 등록이 자동 빈을 오버라이딩 해버린다.</p>

<p><img width="1000" alt="image" src="https://user-images.githubusercontent.com/67885363/176020449-6b6471ad-854b-4d5e-8d31-e56619d1ff75.png" /></p>

<p>개발자가 의도적으로 이런 결과를 기대한 것이라면 좋지만 보통 여러 설정들이 꼬여서 이런 결과가 만들어진다고 한다. 예외가 발생하지 않는 예외상황은 정말 잡기 어려운 버그가 된다. 그래서 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 변경했다고 한다.</p>

<p>만약 수동 빈 등록이 자동 빈 등록을 오버라이딩하는 것을 허용하게 설정을 바꾸고 싶다면 application.properties에서 <code class="language-plaintext highlighter-rouge">spring.main.allow-bean-definition-overriding=true</code>을 작성하면 된다.</p>

<p><br /><br /></p>

<h3 id="빈-생명주기-콜백">빈 생명주기 콜백</h3>

<p>스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.
따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.
그런데 개발자가 의존관계 주입이 모두 완료된 시점을 알 수 없으니, 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 컨테이너가 종료되기 직전에 소멸 콜백을 준다.</p>

<p><strong>스프링 빈의 이벤트 라이프 사이클</strong></p>

<ul>
  <li>스프링 컨테이너 생성</li>
  <li>스프링 빈 생성</li>
  <li>의존관계 주입</li>
  <li>초기화 콜백</li>
  <li>사용</li>
  <li>소멸전 콜백</li>
  <li>스프링 종료</li>
</ul>

<h4 id="스프링이-지원하는-빈-생명주기-콜백-방법-3가지">스프링이 지원하는 빈 생명주기 콜백 방법 3가지</h4>

<p><strong>InitializingBean, DisposableBean</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkClient</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span><span class="o">,</span> <span class="nc">DisposableBean</span> <span class="o">{</span>
    <span class="o">...</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">connect</span><span class="o">();</span>
        <span class="n">call</span><span class="o">(</span><span class="s">"초기화 메시지"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">disconnect</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>스프링 전용 인터페이스이므로 스프링에 의존적이다.</li>
  <li>코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.</li>
</ul>

<p><br /></p>

<p><strong>설정 정보에 빈 등록시 초기화 메서드, 종료 메서드 지정</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Configuration</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">LifeCycleConfig</span> <span class="o">{</span>

        <span class="nd">@Bean</span><span class="o">(</span><span class="n">initMethod</span> <span class="o">=</span> <span class="s">"init"</span><span class="o">,</span> <span class="n">destroyMethod</span> <span class="o">=</span> <span class="s">"close"</span><span class="o">)</span>
        <span class="kd">public</span> <span class="nc">NetworkClient</span> <span class="nf">networkClient</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">NetworkClient</span> <span class="n">networkClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NetworkClient</span><span class="o">();</span>
            <span class="n">networkClient</span><span class="o">.</span><span class="na">setUrl</span><span class="o">(</span><span class="s">"http://hello-spring.dev"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">networkClient</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkClient</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">connect</span><span class="o">();</span>
        <span class="n">call</span><span class="o">(</span><span class="s">"초기화 메시지"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">disconnect</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>@Bean의 destoryMethod 속성에는 메서드 추론 기능이 있다. 라이브러리에서는 대부분 close, shutdown이라는 종료 메서드를 사용한다.
추론 기능은 @Bean에 destoryMethod를 명시하지 않아도 close, shutdown라는 이름의 메서드를 자동으로 호출해준다.</p>

<p>추론 기능을 사용하기 싫으면 detstoryMethod=”“처럼 빈 공백을 지정하면 된다.</p>

<p><br /></p>

<p><strong>@PostConstruct, PreDestroy 어노테이션 지원</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NetworkClient</span> <span class="o">{</span>
	 <span class="nd">@PostConstruct</span>
	 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">connect</span><span class="o">();</span>
	    <span class="n">call</span><span class="o">(</span><span class="s">"초기화 연결 메시지"</span><span class="o">);</span>
	 <span class="o">}</span>
	 
   <span class="nd">@PreDestroy</span>
	 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
     <span class="n">disConnect</span><span class="o">();</span>
	 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 어노테이션들의 패키지를 잘 보면 javax.annotation이다.
스프링에 종속적인 기술이 아니라 JSR-250 라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.</p>

<p>또한 어노테이션 하나만 붙이면 되므로 매우 편리하다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)
토비의 스프링 - vol.1 (이일민 님)</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><summary type="html"><![CDATA[스프링 빈]]></summary></entry><entry><title type="html">MVC 구조</title><link href="http://localhost:4000/spring/MVC-%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="MVC 구조" /><published>2022-06-18T00:00:00+09:00</published><updated>2022-06-18T00:00:00+09:00</updated><id>http://localhost:4000/spring/MVC%20%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="http://localhost:4000/spring/MVC-%EA%B5%AC%EC%A1%B0/"><![CDATA[<h2 id="mvc-구조">MVC 구조</h2>

<p><img width="1020" alt="image" src="https://user-images.githubusercontent.com/67885363/174560490-4ac6fccf-7325-4db4-8f71-4c32cfb2672a.png" /></p>

<h3 id="동작-순서">동작 순서</h3>

<ol>
  <li>DispatcherServlet으로 클라이언트의 웹 요청이 들어온다.</li>
  <li>웹 요청을 핸들러 매핑에 위임해 요청 URL에 매핑된 핸들러를 조회한다.</li>
  <li>핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.</li>
  <li>핸들러 어댑터가 실행되고 핸들러 어댑터가 핸들러를 실행시킨다. 이때 핸들러가 반환한 정보를 핸들러 어댑터가 ModelAndView로 변환해서 반환한다.</li>
  <li>뷰 리졸버가 뷰 이름을 전달받아 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.</li>
  <li>DispatcherServlet은 View에게 Model을 전달하고 화면 표시를 요청한다. 이때, Model이 null이면 View를 그대로 사용하고 Model 값이 있으면 View에 Model 데이터를 렌더링한다.</li>
  <li>DispatcherServlet은 View 결과를 클라이언트에게 반환한다.</li>
</ol>

<p><br />
<br /></p>

<h3 id="프론트-컨트롤러-패턴과-dispatcherservlet">프론트 컨트롤러 패턴과 DispatcherServlet</h3>

<p>DispatcherServlet을 설명하기 전에 프론트 컨트롤러 패턴에 대해 알아보자.
프론트 컨트롤러 패턴이란 모든 요청을 받는 서블릿을 하나로 두고, 서블릿이 요청에 맞는 컨트롤러를 호출해서 처리해주는 것이다.
프론트 컨트롤러 패턴을 도입하면, 컨트롤러를 구현할 때 직접 서블릿을 다루지 않아도 되고, 공통된 로직을 줄임으로써 개발자는 핵심 로직에만 집중할 수 있다.</p>

<ul>
  <li>프론트 컨트롤러 도입 전</li>
</ul>

<p><img width="670" alt="image" src="https://user-images.githubusercontent.com/67885363/175099647-94d7a9d8-bced-4f97-8acb-f32b56e98ac7.png" /></p>

<ul>
  <li>프론트 컨트롤러 도입 후</li>
</ul>

<p><img width="670" alt="image" src="https://user-images.githubusercontent.com/67885363/175099833-c2640c9d-4dc0-42e3-8168-198874b41bed.png" /></p>

<p>우리가 스프링을 이용해 개발을 해오면서 컨트롤러 로직을 작성할 때, 서블릿을 직접 다룬 적이 없었던 이유도 Spring web mvc가 프론트 컨트롤러 패턴을 사용하고 있기 때문이다.</p>

<p>클라이언트로부터 요청이 들어오면 서블릿 컨테이너가 해당하는 서블릿을 실행시키는데 이 때 실행되는 서블릿이 Dispatcher Servlet이다. 공통 작업은 DispatcherServlet에서 처리하고, 이외의 작업은 적절한 세부 컨트롤러를 호출하여 처리한다.</p>

<p><br />
<br /></p>

<h3 id="스프링-mvc-동작방식">스프링 MVC 동작방식</h3>

<p>DispatcherServlet은 FrameworkServlet.java &gt; HttpServlet.java &gt; Servlet.java 를 상속받아 구현한 서블릿으로 Servlet Container에서 들어오는 모든 요청을 먼저 받아 중앙 집중식으로 처리해주는 프론트 컨트롤러다.</p>

<p>DispatcherServlet은 웹 요청에 따른 처리를 해주기 위해 처음으로 <code class="language-plaintext highlighter-rouge">doService()</code>메서드를 호출한다.</p>

<p><img width="854" alt="image" src="https://user-images.githubusercontent.com/67885363/175106591-22c95a30-4ec2-4a8d-adaf-60912ff66c56.png" /></p>

<p>그리고 DispatcherServlet의 핵심인 <code class="language-plaintext highlighter-rouge">doDispatch()</code> 메서드를 호출한다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doDispatch</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span>
            <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">HttpServletRequest</span> <span class="n">processedRequest</span> <span class="o">=</span> <span class="n">request</span><span class="o">;</span>
        <span class="nc">HandlerExecutionChain</span> <span class="n">mappedHandler</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ModelAndView</span> <span class="n">mv</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

		<span class="c1">// 1. 핸들러 조회</span>
        <span class="n">mappedHandler</span> <span class="o">=</span> <span class="n">getHandler</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mappedHandler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">noHandlerFound</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

		<span class="c1">//2.핸들러 어댑터 조회-핸들러를 처리할 수 있는 어댑터</span>
        <span class="nc">HandlerAdapter</span> <span class="n">ha</span> <span class="o">=</span> <span class="n">getHandlerAdapter</span><span class="o">(</span><span class="n">mappedHandler</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>

		<span class="c1">// 3. 핸들러 어댑터 실행 -&gt; 4. 핸들러 어댑터를 통해 핸들러 실행 -&gt; 5. ModelAndView 반환 </span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">ha</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">mappedHandler</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>

        <span class="n">processDispatchResult</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">mappedHandler</span><span class="o">,</span> <span class="n">mv</span><span class="o">,</span>
                <span class="n">dispatchException</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processDispatchResult</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                                       <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HandlerExecutionChain</span> <span class="n">mappedHandler</span><span class="o">,</span> <span class="nc">ModelAndView</span>
                                               <span class="n">mv</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="c1">// 뷰 렌더링 호출</span>
        <span class="n">render</span><span class="o">(</span><span class="n">mv</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">(</span><span class="nc">ModelAndView</span> <span class="n">mv</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                          <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">View</span> <span class="n">view</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">viewName</span> <span class="o">=</span> <span class="n">mv</span><span class="o">.</span><span class="na">getViewName</span><span class="o">();</span>

        <span class="c1">//6. 뷰 리졸버를 통해서 뷰 찾기,7.View 반환</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">resolveViewName</span><span class="o">(</span><span class="n">viewName</span><span class="o">,</span> <span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">locale</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>

		<span class="c1">// 8. 뷰 렌더링</span>
        <span class="n">view</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>먼저 웹 요청을 처리할 수 있는 핸들러를 찾기 위해 <code class="language-plaintext highlighter-rouge">getHandler()</code> 메서드를 호출한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Nullable</span>
	<span class="kd">protected</span> <span class="nc">HandlerExecutionChain</span> <span class="nf">getHandler</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">handlerMappings</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">HandlerMapping</span> <span class="n">mapping</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">handlerMappings</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">HandlerExecutionChain</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="na">getHandler</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">handler</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">handler</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>핸들러 매핑을 순서대로 실행해서, 핸들러를 찾는다.</p>

<blockquote>
  <p>0 = RequestMappingHandlerMapping : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
<br /> 1 = BeanNameUrlHandlerMapping : URL과 일치하는 이름을 갖는 스프링 빈의 이름으로 핸들러를 찾는다.
<br /> 2 = ControllerBeanNameHandlerMapping : URL과 일치하는 이름을 갖는 스프링 빈의 아이디로 핸들러를 찾는다.</p>
</blockquote>

<p>핸들러 매핑으로 HandlerExecutionChain을 결정하는데 HandlerExecutionChain 구현체는 실제로 호출된 핸들러에 대한 참조를 가지고 있다. 즉 무엇이 실행되어야 될지 알고 있는 객체라고 말할 수 있다.</p>

<p>HandlerExecutionChian이 발견되지 않아 null을 반환하면 404 Not Found를 전달하고, 발견되면 HandlerAdapter 결정하러간다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kd">protected</span> <span class="nc">HandlerAdapter</span> <span class="nf">getHandlerAdapter</span><span class="o">(</span><span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">handlerAdapters</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">HandlerAdapter</span> <span class="n">adapter</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">handlerAdapters</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">adapter</span><span class="o">.</span><span class="na">supports</span><span class="o">(</span><span class="n">handler</span><span class="o">))</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">adapter</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">ServletException</span><span class="o">(</span><span class="s">"No adapter for handler ["</span> <span class="o">+</span> <span class="n">handler</span> <span class="o">+</span>
				<span class="s">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>찾은 핸들러를 실행하기 위해 해당 핸들러를 맞는 핸들러 어댑터를 탐색해야 한다. 이를 위해 <code class="language-plaintext highlighter-rouge">getHandlerAdapter()</code>메서드를 호출한다. 핸들러 어댑터도 순서대로 <code class="language-plaintext highlighter-rouge">supports()</code>메서드를 실행해서 찾는다.</p>

<blockquote>
  <p>0 = RequestMappingHandlerAdapter : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
<br /> 1 = HttpRequestHandlerAdapter : HttpRequestHandler 처리
<br /> 2 = SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">mv</span> <span class="o">=</span> <span class="n">ha</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">processedRequest</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">mappedHandler</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>
</code></pre></div></div>

<p>핸들러 어댑터를 이용하여  <code class="language-plaintext highlighter-rouge">handle()</code>메서드로 핸들러의 메서드를 실행하고 그 결과로 ModelAndView를 반환한다.</p>

<p><br /></p>

<p>핸들러가 작업을 마치고 정보를 ModelAndView 타입 오브젝트에 담아서 DispatcherServlet에 돌려주는 방법은 크게 두 가지다. 하나는 View 타입의 오브젝트를 돌려주는 방법이고, 다른 하나는 뷰 이름을 돌려주는 방법이다. 뷰 이름을 돌려주는 경우에는 실제 사용할 뷰를 결정해주는 뷰 리졸버가 필요하다.</p>

<p>다음으로 <code class="language-plaintext highlighter-rouge">processDispatchResult()</code>메서드가 호출된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">processDispatchResult</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                                       <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HandlerExecutionChain</span> <span class="n">mappedHandler</span><span class="o">,</span> <span class="nc">ModelAndView</span>
                                               <span class="n">mv</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">render</span><span class="o">(</span><span class="n">mv</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">processDispatchResult()</code>메서드는  <code class="language-plaintext highlighter-rouge">render()</code>메서드를 호출한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">(</span><span class="nc">ModelAndView</span> <span class="n">mv</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span>
                          <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">View</span> <span class="n">view</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">viewName</span> <span class="o">=</span> <span class="n">mv</span><span class="o">.</span><span class="na">getViewName</span><span class="o">();</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">resolveViewName</span><span class="o">(</span><span class="n">viewName</span><span class="o">,</span> <span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">locale</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>

        <span class="n">view</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">mv</span><span class="o">.</span><span class="na">getModelInternal</span><span class="o">(),</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">render()</code>는 View의 논리 이름을 물리 이름으로 변환시키기 위해 <code class="language-plaintext highlighter-rouge">resolveViewName()</code>메서드를 호출한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Nullable</span>
	<span class="kd">protected</span> <span class="nc">View</span> <span class="nf">resolveViewName</span><span class="o">(</span><span class="nc">String</span> <span class="n">viewName</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">model</span><span class="o">,</span>
			<span class="nc">Locale</span> <span class="n">locale</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">ViewResolver</span> <span class="n">viewResolver</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">View</span> <span class="n">view</span> <span class="o">=</span> <span class="n">viewResolver</span><span class="o">.</span><span class="na">resolveViewName</span><span class="o">(</span><span class="n">viewName</span><span class="o">,</span> <span class="n">locale</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">view</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">return</span> <span class="n">view</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>뷰 리졸버의 여러 구현체의 <code class="language-plaintext highlighter-rouge">resolveViewName()</code> 메서드를 호출하여 View의 논리 이름을 물리 이름으로 변환시킨다.</p>

<blockquote>
  <p>1 = BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. (예: 엑셀 파일 생성 기능에 사용)
<br /> 2 = InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.</p>
</blockquote>

<p>스프링 부트는 InternalResourceViewResolver 뷰 리졸버를 자동으로 등록하는데, 이때 application.properties 에 등록한 spring.mvc.view.prefix , spring.mvc.view.suffix 설정 정보를 사용해서 등록한다.</p>

<p>마지막으로, View 객체의 <code class="language-plaintext highlighter-rouge">render()</code> 메소드를 호출하여 View에 Model 데이터를 렌더링한다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)
토비의 스프링 - vol.1 (이일민 님)</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><summary type="html"><![CDATA[MVC 구조]]></summary></entry><entry><title type="html">서블릿</title><link href="http://localhost:4000/spring/%EC%84%9C%EB%B8%94%EB%A6%BF/" rel="alternate" type="text/html" title="서블릿" /><published>2022-06-17T00:00:00+09:00</published><updated>2022-06-17T00:00:00+09:00</updated><id>http://localhost:4000/spring/%EC%84%9C%EB%B8%94%EB%A6%BF</id><content type="html" xml:base="http://localhost:4000/spring/%EC%84%9C%EB%B8%94%EB%A6%BF/"><![CDATA[<h2 id="서블릿">서블릿</h2>

<h3 id="서블릿-이전의-cgi">서블릿 이전의 CGI</h3>

<p>이전의 웹 프로그램들은 클라이언트의 요청에 대한 응답으로 정적인 리소스만 넘겨주었다.</p>

<p>웹 프로그래밍은 점점 발전하게 되었고, 사용자의 요청에 맞게 동적인 페이지를 작성할 수 있게 되었는데 이 역할을 CGI라는 인터페이스가 해주었다.</p>

<p><img width="732" alt="image" src="https://user-images.githubusercontent.com/67885363/174744583-d8c48a5b-ce55-4148-a0bb-bfb3a825ca8c.png" /></p>

<p>하지만 CGI는 단점이 있었다. CGI는 클라이언트에서 요청이 올 때마다 각각에 대한 처리 프로세스를 만들어냈다. 들어오는 요청들이 같은 CGI 구현체를 사용할지라도 다른 요청이라면 그 때마다 구현체를 만들어서 처리해주었다.</p>

<p>대량의 요청이 들어온다고 가정했을 때, 각 요청마다 프로세스를 만든다는 것은 정말 비효율적이지 않은가?</p>

<p>이 문제를 서블릿이 해결해준다.</p>

<p><br /></p>

<h3 id="서블릿-1">서블릿</h3>

<p>서블릿이란 클라이언트 요청을 처리하고, 결과를 처리해서 반환해주는 Java 인터페이스다.</p>

<p><img width="897" alt="image" src="https://user-images.githubusercontent.com/67885363/174748310-0f5c27de-773c-4fa9-b30b-b7795ee69b17.png" /></p>

<p>Servlet에 정의된 HttpServletRequest나 ServletResponse 객체들을 사용하면 HTTP 요청 정보를 쉽게 사용할 수 있고, 처리결과를 쉽게 응답할 수 있다.</p>

<p>서블릿이 요청 HTTP 메시지를 읽고 응답 HTTP 메시지를 만들어주니 개발자는 처리 로직에만 집중할 수 있다.</p>

<p><img src="/Users/hongdong-geon/Library/Application Support/typora-user-images/image-20220621165631171.png" alt="image-20220621165631171" /></p>

<p>또한 서블릿은 싱글톤 패턴으로 CGI의 문제점을 해결해주었다.</p>

<p>서블릿은 각 요청에 대한 프로세스를 생성하는 것이 아니라, 프로세스 1개가 있고 그 내부에 스레드들을 생성하여 처리했다.</p>

<p><br /></p>

<h3 id="서블릿-라이프-사이클-흐름">서블릿 라이프 사이클 흐름</h3>

<p>서블릿에는 init(), service(), destroy() 메서드가 정의되어 있다.</p>

<p><img width="914" alt="image" src="https://user-images.githubusercontent.com/67885363/174750014-b7257c2e-64e9-40bd-9cf0-44a054558231.png" /></p>

<p>웹 어플리케이션 서버를 실행시키면, 서블릿이 생성되고 톰캣과 같은 서블릿 컨테이너에 등록된다.</p>

<p>클라이언트에서 요청이 들어오면 서블릿이 실행되면서 요청에 대한 처리를 해주고 응답값을 반환해준다.</p>

<p>웹 어플리케이션 서버를 중지시키면, 서블릿은 소멸된다.</p>

<p><img width="765" alt="image" src="https://user-images.githubusercontent.com/67885363/174756812-502da54b-49c8-4e38-83cb-1bca8f1f546a.png" /></p>

<p>위의 콘솔창을 보면<code class="language-plaintext highlighter-rouge">/hello</code> 경로로 2번 요청이 들어온 것을 볼 수 있다.</p>

<p>여기서 중요한게 2번째 요청이 들어올 때, init 메서드가 호출되는 것이 아니라, 이전에 메모리에 남겨두었던 것을 재사용한다.</p>

<p>생성된 Servlet 객체는 메모리에 남겨두고 동일한 서블릿에 대해 요청이 온다면 재사용한다. Servlet은 싱글톤 패턴을 통해 사용되기 때문에 하나의 구현체를 통해 동작할 수 있다.</p>

<p><br /></p>

<h3 id="서블릿-컨테이너">서블릿 컨테이너</h3>

<p>서블릿은 스스로 작동하는 것이 아니고 서블릿을 생성, 소멸 및 관리해주는 것이 필요하다. 이런 서블릿을 관리해주는 역할을 하는 것이 서블릿 컨테이너이다. 톰캣이 서블릿 컨테이너의 대표적인 예시다.</p>

<p>서블릿 컨테이너의 대표적인 역할로는 서블릿의 생명주기를 관리해주고, 클라이언트의 요청을 받고 응답할 수 있도록 웹 서버와 소켓으로 통신해준다.</p>

<p>또한 서블릿 컨테이너는 요청마다 자바 스레드를 생성해주고, 요청이 완료되면 스레드를 죽이는 멀티 스레드 지원 및 관리 역할을 한다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><summary type="html"><![CDATA[서블릿]]></summary></entry><entry><title type="html">웹 어플리케이션 서버</title><link href="http://localhost:4000/spring/%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B2%84/" rel="alternate" type="text/html" title="웹 어플리케이션 서버" /><published>2022-06-16T00:00:00+09:00</published><updated>2022-06-16T00:00:00+09:00</updated><id>http://localhost:4000/spring/%EC%9B%B9%20%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%84%9C%EB%B2%84</id><content type="html" xml:base="http://localhost:4000/spring/%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B2%84/"><![CDATA[<p>웹은 HTTP 기반으로 통신한다. 클라이언트에서 서버로 데이터를 전송할 때, 서버에서 클라이언트로 데이터를 응답할 때 모두 HTTP 프로토콜 기반으로 동작한다.</p>

<p><br /></p>

<h3 id="웹-서버">웹 서버</h3>

<ul>
  <li>HTTP 기반으로 동작</li>
  <li>정적 리소스 제공, 기타 부가기능
    <ul>
      <li>정적인 파일을 제공하므로 HTML 을 특정 사용자마다 다르게 보여줄 수 있음</li>
      <li>정적 HTML, CSS, JS, 이미지, 영상</li>
    </ul>
  </li>
  <li>웹 서버에서 요청에 알맞은 파일을 반환하며, 항상 동일한 페이지를 반환</li>
  <li>예) NGINX, APACHE</li>
</ul>

<p><br /></p>

<h3 id="웹-애플리케이션-서버was">웹 애플리케이션 서버(WAS)</h3>

<ul>
  <li>HTTP 기반으로 동작</li>
  <li>웹 서버 기능 포함 (정적 리소스 제공 가능)</li>
  <li>프로그램 코드를 실행해서 애플리케이션 로직 수행
    <ul>
      <li>동적 HTML, HTTP API(JSON)</li>
      <li>사용자에 따라서 다른 화면들을 보여줄 수 있다.</li>
    </ul>
  </li>
  <li>들어온 요청에 맞게 동적으로 만들어진 컨텐츠로 데이터베이스, 서버 내 로직 등을 활용해 만들어진 컨텐츠를 반환</li>
  <li>서블릿, 스프링 MVC가 WAS에서 동작</li>
  <li>Tomcat, Jetty, Undertow</li>
</ul>

<p><br /></p>

<h3 id="웹-시스템-구성">웹 시스템 구성</h3>

<p><img width="620" alt="image" src="https://user-images.githubusercontent.com/67885363/174735563-d139bbcf-969c-4b31-a85c-100840bac322.png" /></p>

<ul>
  <li>역할 분리</li>
</ul>

<p>웹 시스템을 구성할 때 WAS, DB 만으로 시스템 구성이 가능하다. WAS는 정적 리소스, 어플리케이션 로직 모두 제공 가능하기 때문이다. 그러나 WAS가 너무 많은 역할을 담당하면 서버 과부하가 우려 된다. HTML, CSS, JS 파일 같은 경우는 시스템적으로 단순하고 값이 싸다. 그러나 어플리케이션 로직은 비즈니스 로직이므로 값이 비싸다. 어플리케이션 로직이 정적 리소스 때문에 수행이 어려우면 안되므로 역할을 분리해준다.</p>

<ul>
  <li>장애 발생시</li>
</ul>

<p>정적 리소스만 제공하는 웹 서버는 잘 죽지 않고 대부분의 장애는 WAS에서 발생한다. 하지만 WAS는 장애가 발생하면 요청하는 웹 브라우저에서 WAS로 접근조차 되지 않으므로 오류 화면 조차도 노출이 불가능하다. WAS 서버가 죽더라도 웹 서버가 WAS 에 요청을 했는데 응답이 없거나 잘 연결되지 않으면 오류화면 HTML 제공하도록 설정할 수 있다.</p>

<ul>
  <li>리소스 관리</li>
</ul>

<p>WAS는 중요한 어플리케이션 로직 처리에 전담할 수 있다. 그리고 시스템 리소스를 효율적으로 관리할 수 있다. 정적인 리소스가 많이 필요하면 웹 서버를 증설하면 되고 어플리케이션 리소스가 많이 사용되면 WAS를 증설하면 된다.</p>

<p><br /></p>

<h3 id="웹-어플리케이션-서버-vs-웹-컨테이너-서블릿-컨테이너">웹 어플리케이션 서버 vs 웹 컨테이너 (서블릿 컨테이너)</h3>

<p>톰캣을 부를 때, 어플리케이션 서버와 서블릿 컨테이너를 혼용해서 사용하는 경우가 잦아서 두 키워드에 혼란이 있었다. 톰캣은 굳이 둘 중에 하나로 분류하자고 하면 서블릿 컨테이너 쪽에 가깝다고 한다.</p>

<p>왜냐하면 톰캣은 서블릿과 JSP를 위한 런타임 환경을 제공하나 어플리케이션 서버의 필수적이라고 할 수 있는 EJB 같은 기술이 적용되어 있지 않기 때문이다.</p>

<p>서블릿 컨테이너는 오직 서블릿 API 만 지원하는 것을 말하고 어플리케이션 서버는 Java EE (EJB, CDI, 서블릿 API 등..)의 전체를 지원한다고 한다.</p>

<p>하지만, 톰캣은 서블릿 뿐만 아니라 JSP 같은 것도 실행할 수 있기 때문에 서블릿 컨테이너라고 부르는 것이 맞다라는 관점도 있고, 톰캣이 서블릿 컨테이너를 포함하고 있는 개념이라는 관점도 있다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)</p>
</blockquote>]]></content><author><name>kun</name></author><category term="spring" /><summary type="html"><![CDATA[웹은 HTTP 기반으로 통신한다. 클라이언트에서 서버로 데이터를 전송할 때, 서버에서 클라이언트로 데이터를 응답할 때 모두 HTTP 프로토콜 기반으로 동작한다.]]></summary></entry><entry><title type="html">스프링 컨테이너</title><link href="http://localhost:4000/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/" rel="alternate" type="text/html" title="스프링 컨테이너" /><published>2022-06-15T00:00:00+09:00</published><updated>2022-06-15T00:00:00+09:00</updated><id>http://localhost:4000/%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id><content type="html" xml:base="http://localhost:4000/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/"><![CDATA[<h2 id="스프링-컨테이너">스프링 컨테이너</h2>

<h3 id="스프링-컨테이너란">스프링 컨테이너란?</h3>

<p>스프링 컨테이너는 스프링 빈의 생명 주기를 관리하여  IoC(제어역전)와 DI(의존성주입)을 제공해주는 역할을 한다.</p>

<p>스프링 컨테이너는 Bean Factory와 이를 상속한 ApplicationContext 2가지 유형이 존재한다.</p>

<p><br /></p>

<h4 id="bean-factory">Bean Factory</h4>

<p>Bean Factory는 스프링 컨테이너의 최상위 인터페이스로 스프링 컨테이너 설정파일에 등록된 Bean 객체를 생성하고 관리하는 기본적인 기능만 담당하는 IoC 컨테이너이자 클래스를 말한다.
컨테이너가 구동될 때 Bean 객체를 생성하는 것이 아니라 빈 사용 요청에 의해서 Bean 객체가 사용되는 시점(Lazy Loading) 에 객체를 생성하는 방식이다.</p>

<p><br /></p>

<h4 id="applicationcontext">ApplicationContext</h4>

<p>ApplicationContext는 BeanFactory 인터페이스의 하위 인터페이스로 빈 관리 기능(DI 와 IoC) 뿐만 아니라 편리한 부가 기능을 제공한다. 트랜잭션 관리, 메시지 기반의 다국어 처리, AOP 처리 등 많은 부분을 지원한다.
컨테이너가 구동되는 시점에 Bean 객체들을 생성하는 방식이다.</p>

<p><br /></p>

<h3 id="스프링-컨테이너-생성과정">스프링 컨테이너 생성과정</h3>

<ul>
  <li>스프링 컨테이너가 생성된다.</li>
  <li>스프링 빈을 등록한다.
    <ul>
      <li>수동 빈 등록을 한다면 설정 정보를 읽어서 스프링 빈을 등록한다.</li>
      <li>자동 빈 등록을 한다면 @Component가 붙은 클래스들을 스프링 빈으로 등록한다.</li>
    </ul>
  </li>
  <li>스프링 빈의 의존관계를 설정한다.
    <ul>
      <li>수동 빈 등록을 할시에는 설정 정보를 읽어서 의존관계를 주입한다.</li>
      <li>자동 빈 등록을 할시에는 등록된 빈에 생성자나 @Autowired를 보고 의존관계를 주입한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="스프링이-설정-파일을-읽는-과정">스프링이 설정 파일을 읽는 과정</h3>

<p>XML 설정 파일이나 자바 설정 파일에 빈을 정의해주면 해당 설정 파일을 이용해 스프링 컨테이너가 빈 정의 내용대로 빈을 관리하도록 한다.</p>

<p>스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까?</p>

<p>그 중심에는 BeanDefinition이라는 추상화가 있다. XML이든 자바 코드든 읽어서 BeanDefinition을 만들면 된다.
스프링 컨테이너는 자바 코드인지, XML인지 몰라도 되고 오직 BeanDefinition만 알면 된다.</p>

<p>BeanDefinition은 빈 설정 메타정보라고 한다. 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.</p>

<p><img width="672" alt="image" src="https://user-images.githubusercontent.com/67885363/176005470-9d8265e6-9fb2-4d3e-87bd-138676a1db78.png" /></p>

<p><br /></p>

<h3 id="싱글턴-패턴">싱글턴 패턴</h3>

<p>스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다. 
웹 어플리케이션은 보통 여러 고객이 동시에 요청을 하는데 만약 대량의 트래픽이 들어왔을 때 요청마다 객체가 생성되고 소멸된다면 메모리 낭비가 심할 것이다. 
스프링의 해결 방안으로는 싱글톤 패턴을 사용하여 해당 객체를 1개만 생성하게 하고 공유하도록 하는 것이다.</p>

<p>하지만 싱글톤 패턴에는 여러가지 문제점이 있다.</p>

<ul>
  <li>private 생성자를 갖고 있기 때문에 상속할 수 없다.</li>
  <li>싱글톤은 테스트하기가 힘들다.</li>
  <li>필드에 공유 값을 설정하면 큰 장애가 발생할 수 있다.</li>
</ul>

<p>스프링은 이런 싱글톤 패턴의 문제점을 해결했다.</p>

<p>스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만듭니다.</p>

<p>여기서 싱글톤은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 구현 방법은 다릅니다.</p>

<p><br /></p>

<h3 id="싱글턴-레지스트리">싱글턴 레지스트리</h3>

<p>스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.
여기서 싱글톤은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 구현 방법은 다르다. 또한 위의 싱글톤 패턴의 단점들을 보완한 상태를 사용한다.
이렇게 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리라고 할 수 있다.</p>

<p>private 생성자로 객체의 생성을 막는 방법이 아니라 일반 자바 클래스를 싱글톤으로 활용할 수 있도록 지원한다.</p>

<p>가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식의 원칙, 디자인 패턴 등을 적용하는데 아무런 제약이 없게 만들어준다는 것입니다.</p>

<p><br />
<br /></p>

<blockquote>
  <p>참고 <br />
스프링 핵심 원리 - 기본편 (김영한 님)
토비의 스프링 - vol.1 (이일민 님)</p>
</blockquote>]]></content><author><name>kun</name></author><summary type="html"><![CDATA[스프링 컨테이너]]></summary></entry><entry><title type="html">테스트 범위에 따른 테스트 종류</title><link href="http://localhost:4000/java/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B2%94%EC%9C%84%EC%97%90-%EB%94%B0%EB%A5%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A2%85%EB%A5%98/" rel="alternate" type="text/html" title="테스트 범위에 따른 테스트 종류" /><published>2022-05-14T00:00:00+09:00</published><updated>2022-05-14T00:00:00+09:00</updated><id>http://localhost:4000/java/%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EB%B2%94%EC%9C%84%EC%97%90%20%EB%94%B0%EB%A5%B8%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A2%85%EB%A5%98</id><content type="html" xml:base="http://localhost:4000/java/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%B2%94%EC%9C%84%EC%97%90-%EB%94%B0%EB%A5%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A2%85%EB%A5%98/"><![CDATA[<p>테스트의 범위는 테스트의 목적과 수행하는 사람에 따라 달라진다.</p>

<p>일반적인 웹 어플리케이션에서 테스트 범위에 따른 테스트 종류는 아래의 그림과 같이 세 가지로 나눌 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/168793597-130da346-35b2-4760-89c7-2a51036ff3ae.png" alt="image" /></p>

<p><br /></p>

<h3 id="기능-테스트와-e2e-테스트">기능 테스트와 E2E 테스트</h3>

<p>기능 테스트는 사용자 입장에서 시스템이 제공하는 기능이 올바르게 동작하는지 확인한다.</p>

<p>기능 테스트를 수행하려면 시스템을 구동하고 사용하는데 필요한 모든 구성 요소가 필요하다.</p>

<p>기능 테스트는 사용자가 직접 사용하는 웹 브라우저부터 DB나 외부 서비스에 이르기까지 모든 구성 요소를 논리적으로 완전한 하나의 기능으로 다룬다.</p>

<p>기능 테스트는 끝에서 끝까지 올바른지 검사하기 때문에 E2E 테스트로도 볼 수 있다.</p>

<blockquote>
  <p>기능 테스트의 결과를 검증하기 위해 DB 데이터를 직접 조회할 수는 있지만, 이것은 마치 테스터가 브라우저로 회원 가입 기능을 실행한 뒤에 DB에 SELECT 쿼리를 보내서 데이터가 잘 들어갔는지 확인하는 것과 같다. 보통의 기능 테스트라면 회원 가입을 실행한 후에 데이터가 올바르게 들어갔는지 확인하기 위해 개인 정보 조회 화면을 실행하거나 관리 도구의 회원 정보 조회 기능을 실행할 것이다. 부득이한 경우를 제외하면 기능 테스트는 사용자와 동일한 방식으로 기능을 검증해야 한다.</p>
</blockquote>

<p><br /></p>

<h3 id="통합-테스트">통합 테스트</h3>

<p>통합 테스트는 시스템의 각 구성 요소가 올바르게 연동되는지 확인한다.</p>

<p>기능 테스트가 사용자 입장에서 테스트하는데 반해, 통합 테스트는 소프트웨어 코드를 직접 테스트한다.</p>

<p>기능 테스트는 가입 기능을 테스트한다면 통합 테스트는 서버의 회원 가입 코드를 직접 테스트하는 것이다.</p>

<p>일반적인 웹 어플리케이션은 프레임워크, 데이터베이스, 구현한 코드가 주요 통합 테스트의 대상이다.</p>

<p><br /></p>

<h3 id="단위-테스트">단위 테스트</h3>

<p>단위 테스트는 개별 코드나 컴포넌트가 기대한대로 동작하는지 확인한다.</p>

<p>단위 테스트는 한 클래스나 한 메서드와 같은 작은 범위를 테스트한다.</p>

<p>일부 의존 대상은 스텁이나 모의 객체 등을 이용해서 대역으로 대체한다.</p>

<p><br /></p>

<h3 id="테스트-범위간-차이">테스트 범위간 차이</h3>

<ul>
  <li>
    <p>기능 테스트</p>

    <p>웹 서버를 구동하거나 모바일 앱을 폰에 설치해야 할 수도 있다. 브라우저나 앱을 구동하고 화면의 흐름에 따라 알맞은 상호 작용을 해야 한다.</p>
  </li>
  <li>
    <p>통합 테스트 : 실행하려면 DB나 캐시 서버와 같은 연동 대상을 구성해야 한다.</p>
  </li>
</ul>

<p>​		DB 연결, 소켓 통신, 스프링 컨테이너 최고하와 같이 테스트 실행 속도를 느리게 만드는 요인이 많다.</p>

<ul>
  <li>단위 테스트 : 코드를 제외하고는 따로 준비할 것이 없다.</li>
</ul>

<p>​		서버를 구동하거나 DB를 준비할 필요가 없다. 테스트 대상이 의존하는 기능을 대역으로 처리하면 되므로 실행속도가 빠르다</p>

<blockquote>
  <p>통합 테스트를 실행하려면 준비할 것이 많고 단위 테스트에 비해 실행 시간도 길지만, 그래도 통합 테스트는 필요하다. 아무리 단위 테스트를 많이 만든다고 해도 결국은 각 구성 요소가 올바르게 연동되는 것을 확인해야 하는데 이를 자동화하기 좋은 수단이 통합 테스트 코드이기 때문이다.</p>
</blockquote>]]></content><author><name>kun</name></author><category term="java" /><summary type="html"><![CDATA[테스트의 범위는 테스트의 목적과 수행하는 사람에 따라 달라진다.]]></summary></entry><entry><title type="html">JDBC란</title><link href="http://localhost:4000/java/JDBC%EB%9E%80/" rel="alternate" type="text/html" title="JDBC란" /><published>2022-04-07T00:00:00+09:00</published><updated>2022-04-07T00:00:00+09:00</updated><id>http://localhost:4000/java/JDBC%EB%9E%80</id><content type="html" xml:base="http://localhost:4000/java/JDBC%EB%9E%80/"><![CDATA[<h2 id="jdbc란">JDBC란</h2>

<p>JDBC(Java DataBase Connectivity)는 자바 프로그램에서 Database를 조작하게 해주는 API이다.
JDBC API는 JDK에서 제공하며 JDBC 프로그래밍을 위해서는 JDBC드라이버가 필요하다. 
JDBC 드라이버는 각 DBMS 회사에서 제공하는 라이브러리 압축파일이다. 
이번 체스 미션에서는 MySQL을 사용하기 때문에, MySQL 드라이버를 사용했다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/162207853-e28cc639-7c5c-41f6-9b29-65d969639e88.png" alt="image" /></p>

<p><br /></p>

<h3 id="jdbd-api-클래스">JDBD API 클래스</h3>

<p>JDBC 클래스와 인터페이스는 자바 패키지 java.sql과 javax.sql에 포함되어 있다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/162208272-33c76821-16ac-4c9d-8271-a0f5e26b2d16.png" alt="image" /></p>

<p><br /></p>

<h3 id="jdbc를-이용한-데이터베이스-연동과정">JDBC를 이용한 데이터베이스 연동과정</h3>

<p><strong>JDBC 드라이버 로드</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Class.forName("com.mysql.cj.jdbc.Driver")</code> 를 호출하여, mysql에서 제공하는 Driver 클래스를 JVM method area에 로딩시킨다.</p>

<p><br /></p>

<p><strong>데이터베이스 연결</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">URL</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3307/chess"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">USER</span> <span class="o">=</span> <span class="s">"user"</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">PASSWORD</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>
    
		<span class="nc">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="no">URL</span><span class="o">,</span> <span class="no">USER</span><span class="o">,</span> <span class="no">PASSWORD</span><span class="o">);</span>
</code></pre></div></div>

<p>URL에는 MySQL의 포트번호와 데이터베이스 이름을 지정해주면 된다.
로컬 환경에서 MySQL의 포트번호는 3306이다. 
체스 미션에서는 docker 환경에서 MySQL 을 사용했기 때문에, 포트를 3307로 지정해주었다. (저는 기존에 따로, 로컬 환경에서 3306 포트를 사용하고 있었습니다.)</p>

<p>이제 Connection 객체를 만들어 사용하게 되는데, DriverManager의 getConnection() 을 호출해서, MySQL에 연결하기 위한 커넥션 정보를 입력한다.
Connection 객체가 만들어지면, Query 문을 실행시키는 statement 객체를 생성할 수 있다.</p>

<p><br /></p>

<p><strong>Query 실행을 위한 객체 생성</strong></p>

<ul>
  <li>Statement</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"insert into board (position, piece, color, game_id) values ('"</span> <span class="o">+</span> <span class="n">position</span> <span class="o">+</span><span class="s">", "</span> <span class="o">+</span> <span class="n">piece</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">color</span> <span class="o">+</span><span class="s">", "</span> <span class="o">+</span> <span class="n">game_id</span> <span class="o">+</span> <span class="s">"')"</span><span class="o">;</span>
<span class="nc">Statement</span> <span class="n">statement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
<span class="n">statement</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>PreparedStatement (Statement 를 상속한 인터페이스)</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">final</span> <span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"insert into board (position, piece, color, game_id) values (?, ?, ?, ?)"</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">statement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">));</span>
<span class="n">statement</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">position</span><span class="o">);</span>
<span class="n">statement</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">piece</span><span class="o">);</span>
<span class="n">statement</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">color</span><span class="o">);</span>
<span class="n">statement</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
<span class="n">statement</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>

</code></pre></div></div>

<p>SQL 서버 엔진이 쿼리를 수행할 때 다음 과정을 거친다.</p>

<ol>
  <li>구문 분석 및 정규화 단계 : 쿼리 문법 및 테이블과 칼럼이 존재 여부를 확인한다.</li>
  <li>컴파일 단계 : 쿼리를 컴파일한다.</li>
  <li>쿼리 최적화 계획 : 쿼리를 실행할 수 있는 방법의 수와 비용을 알아내 최적의 계획을 선택한다.</li>
  <li>캐시 : 선택된 계획은 캐시에 저장되고 동일한 쿼리가 들어올때마다 Cache 찾아 실행한다. (1, 2, 3 단계는 실행되지 않는다.)</li>
  <li>실행 단계 : 쿼리가 실행되고 데이터가 ResultSet 객체로 사용자에게 반환된다.</li>
</ol>

<p>그럼 Statement와 PreparedStatement의 차이가 뭘까?</p>

<p>Statement와 PreparedStatement의 차이는 캐시 사용여부이다.</p>

<p>Statement는 쿼리를 실행할 때마다 위의 1~5 단계를 수행해야 한다.</p>

<p>PreparedStatement는 위의 코드를 보다 시피, 완전한 쿼리가 아니다. 
쿼리의 틀을 미리 생성해 놓고 물음표를 대체할 값을 나중에 지정한다.
따라서 PreparedStatement가 처음 실행될 때만 1~3 단계를 수행 하고  캐시에 담아 재사용하게 한다.
이후에 <code class="language-plaintext highlighter-rouge">Placeholder Replacement</code> 라는 추가 단계가 있는데, 런타임시에 사용자가 입력한 데이터로 set메서드를 사용해 ?를 대체한다.</p>

<p><br /></p>

<p>참고</p>

<p>https://velog.io/@jsj3282/Statement%EB%B3%B4%EB%8B%A4-Preparedstatement%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EC%84%B1%EB%8A%A5-%EB%B3%B4%EC%95%88-%EC%B8%A1%EB%A9%B4</p>]]></content><author><name>kun</name></author><category term="java" /><summary type="html"><![CDATA[JDBC란]]></summary></entry><entry><title type="html">Collections.unmodifiableList() vs List.copyOf()</title><link href="http://localhost:4000/java/copyOf()vsUnmodifiable/" rel="alternate" type="text/html" title="Collections.unmodifiableList() vs List.copyOf()" /><published>2022-03-14T00:00:00+09:00</published><updated>2022-03-14T00:00:00+09:00</updated><id>http://localhost:4000/java/copyOf()vsUnmodifiable</id><content type="html" xml:base="http://localhost:4000/java/copyOf()vsUnmodifiable/"><![CDATA[<p>이전 내용을 간략하게 요약해보자.<br />
인자로 들어올 원본 List의 변화가 객체 내부 필드의 변화까지 일어나지 않게 하기 위해 방어적 복사를 해주었다.<br />
방어적 복사를 하게 되면, 원본 List와 객체 내부 필드의 참조 값이 달라지면서, 외부의 변화에 대해 막아줄 수 있었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">(</span><span class="n">initialCards</span><span class="o">);</span> <span class="c1">// new ArrayList&lt;&gt;()를 이용해 복사본을 만들었다. -&gt; 방어적 복사</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cards</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>그렇다면, 이제 <code class="language-plaintext highlighter-rouge">List&lt;Card&gt; cards</code>를 외부에서의 변화에 걱정하지 않고 사용할 수 있을까? <br />
아니다. <code class="language-plaintext highlighter-rouge">getCards()</code>로 리스트를 불러와, 변경시킨다면 Cards의 필드에도 변화가 가해질 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">initialCards</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Card</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Symbol</span><span class="o">.</span><span class="na">DIAMOND</span><span class="o">,</span> <span class="nc">Denomination</span><span class="o">.</span><span class="na">FIVE</span><span class="o">));</span>
        <span class="n">initialCards</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Card</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Symbol</span><span class="o">.</span><span class="na">DIAMOND</span><span class="o">,</span> <span class="nc">Denomination</span><span class="o">.</span><span class="na">FOUR</span><span class="o">));</span>

        <span class="nc">Cards</span> <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cards</span><span class="o">(</span><span class="n">initialCards</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Card</span> <span class="n">card</span> <span class="o">:</span> <span class="n">cards</span><span class="o">.</span><span class="na">getCards</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"card = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">", card content = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">.</span><span class="na">getDenomination</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span><span class="n">card</span><span class="o">.</span><span class="na">getSymbol</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="n">cards</span><span class="o">.</span><span class="na">getCards</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="nc">Card</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Symbol</span><span class="o">.</span><span class="na">HEART</span><span class="o">,</span> <span class="nc">Denomination</span><span class="o">.</span><span class="na">THREE</span><span class="o">));</span> <span class="c1">// getter()로 List를 불러와 새로운 Card 추가</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Card</span> <span class="n">card</span> <span class="o">:</span> <span class="n">cards</span><span class="o">.</span><span class="na">getCards</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"card = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">", card content = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">.</span><span class="na">getDenomination</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span><span class="n">card</span><span class="o">.</span><span class="na">getSymbol</span><span class="o">());</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/67885363/158881619-6675b204-5f18-41ac-a12a-a10cc17c6328.png" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">Cards</code>의 <code class="language-plaintext highlighter-rouge">getter()</code>를 이용해 List를 불러와 새로운 카드를 추가하였다.<br />
그렇다면, <code class="language-plaintext highlighter-rouge">getter()</code>에서도 필드를 그대로 반환해주는 것이 아닌, 방어적 복사를 해서 외부에서의 변화를 막아주자.</p>

<p><br /></p>

<h3 id="첫번째-방법-new-arraylist">첫번째 방법, new ArrayList()</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>
  
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">(</span><span class="n">initialCards</span><span class="o">);</span> <span class="c1">// new ArrayList&lt;&gt;()를 이용해 복사본을 만들었다. -&gt; 방어적 복사</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">cards</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getter()</code>에서도 방어적 복사를 함으로써, 필드의 참조값과 <code class="language-plaintext highlighter-rouge">getCards()</code>가 반환하는 List의 참조 값을 다르게 해주었다.</p>

<p><br /></p>

<h3 id="두번째-방법-collectionsunmodifiablelist">두번째 방법, Collections.unmodifiableList()</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">initialCards</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableList</span><span class="o">(</span><span class="n">cards</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/67885363/158884061-518ed7d1-641f-47a2-8849-14a1a71baf3a.png" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">Unmodifiable Collection</code>을 이용하는 경우에, 외부에서 변경 시 예외가 발생한다.<br />
<code class="language-plaintext highlighter-rouge">unmodifiableList()</code> 메서드를 통해 리턴되는 리스트는 읽기 용도로만 사용할 수 있다.<br />
리스트에 변경을 가하는 메서드를 호출하면 <code class="language-plaintext highlighter-rouge">UnsupportedOperationException</code> 이 발생한다.</p>

<p><br /></p>

<h3 id="세번째-방법-listcopyof">세번째 방법, List.copyOf()</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">initialCards</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">List</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">cards</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/67885363/158885545-095c9184-bffd-494c-92f7-de5dff8d5b93.png" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">copyOf</code>를 이용하였을 때도 <code class="language-plaintext highlighter-rouge">UnsupportedOperationException</code>이 발생했다.
<code class="language-plaintext highlighter-rouge">List.copyOf()</code>로 반환되는 List도 수정이 불가한가보다.
그렇다면, <code class="language-plaintext highlighter-rouge">Collections.unmodifiableList()</code>와 <code class="language-plaintext highlighter-rouge">List.copyOf()</code>의 차이가 뭘까?</p>

<p><br /></p>

<h3 id="collectionsunmodifiablelist-vs-listcopyof">Collections.unmodifiableList() vs List.copyOf()</h3>

<p>둘의 차이점을 알아보기 위해, 간단한 코드를 작성해보겠다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyOfTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">values</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">unmodifiableList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableList</span><span class="o">(</span><span class="n">values</span><span class="o">);</span>
        
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">copyOfList</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">values</span><span class="o">);</span>

        <span class="n">values</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"===========unmodifiableList==============="</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span> <span class="o">:</span> <span class="n">unmodifiableList</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integer</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"===========copyOf================"</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span> <span class="o">:</span> <span class="n">copyOfList</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integer</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 결과 값은 어떻게 될까?</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/67885363/158887087-dbfcc0e1-b411-4209-9f19-4a6be120d746.png" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">unmodifiableList</code>는 원본 값에 영향을 받고 있다.<br />
원본 리스트에 새로운 값을 추가해주니, 변화하였다.<br />
하지만, <code class="language-plaintext highlighter-rouge">copyOfList</code>는 변화하지 않았다. 왜?<br />
<code class="language-plaintext highlighter-rouge">List.copyOf</code>는  원본과의 참조를 끊어주기 때문이다.</p>

<p>차이점으로, <code class="language-plaintext highlighter-rouge">Collections.unmodifiableList()</code>로는  참조가 끊어져 있지 않다.<br />
 따라서, <code class="language-plaintext highlighter-rouge">Collections.unmodifiableList()</code>로 반환한 리스트를 직접 수정할 수는 없지만, 원본 리스트를 수정한다면 함께 수정이 일어난다.<br /></p>

<p><code class="language-plaintext highlighter-rouge">Unmodifiable</code>과 <code class="language-plaintext highlighter-rouge">Immutable</code>은 다르다.<br />
 <code class="language-plaintext highlighter-rouge">Unmodifiable</code>이라는 키워드가 불변을 보장해주지는 않는다.<br />
원본 자체에 대한 수정이 일어나면 <code class="language-plaintext highlighter-rouge">unmodifiableList()</code> 메서드를 통해 리턴되었던 리스트 또한 변경이 일어난다.</p>

<p><br /></p>

<h3 id="이제-정말-불변일까">이제, 정말 불변일까?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">initialCards</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">List</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">cards</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>생성자에 들어올 원본 리스트와의 주소 값도 끊어주었고, <code class="language-plaintext highlighter-rouge">getCards()</code>로 리스트를 반환할 때도 <code class="language-plaintext highlighter-rouge">copyOf()</code>를 이용해, 외부에서의 변화에 대해 막아주었다.<br />
하지만, <code class="language-plaintext highlighter-rouge">new ArrayList()</code>, <code class="language-plaintext highlighter-rouge">Collections.unmodifiableList()</code>, <code class="language-plaintext highlighter-rouge">copyOf()</code> 모두 깊은 복사를 한 것이 아니다.<br />
즉, 리스트의 참조 값만 끊어 준 것이지, 리스트 내부의 객체 참조 값은 동일하다.<br />
만약 Card 클래스에 <code class="language-plaintext highlighter-rouge">setter()</code>가 존재한다면, <code class="language-plaintext highlighter-rouge">cards</code>는 외부에서 얼마든지 변할 수 있다.<br />
그렇다고 꼭 깊은 복사를 해야한다는 것은 아니다.<br />
<code class="language-plaintext highlighter-rouge">Card</code>가 불변 객체라면, 방어적 복사만으로도 <code class="language-plaintext highlighter-rouge">cards</code>는 충분히 안전한 리스트라고 할 수 있다고 생각한다.</p>]]></content><author><name>kun</name></author><category term="java" /><summary type="html"><![CDATA[이전 내용을 간략하게 요약해보자. 인자로 들어올 원본 List의 변화가 객체 내부 필드의 변화까지 일어나지 않게 하기 위해 방어적 복사를 해주었다. 방어적 복사를 하게 되면, 원본 List와 객체 내부 필드의 참조 값이 달라지면서, 외부의 변화에 대해 막아줄 수 있었다.]]></summary></entry><entry><title type="html">방어적 복사</title><link href="http://localhost:4000/java/%EB%B0%A9%EC%96%B4%EC%A0%81-%EB%B3%B5%EC%82%AC%EB%9E%80/" rel="alternate" type="text/html" title="방어적 복사" /><published>2022-03-13T00:00:00+09:00</published><updated>2022-03-13T00:00:00+09:00</updated><id>http://localhost:4000/java/%EB%B0%A9%EC%96%B4%EC%A0%81%20%EB%B3%B5%EC%82%AC%EB%9E%80</id><content type="html" xml:base="http://localhost:4000/java/%EB%B0%A9%EC%96%B4%EC%A0%81-%EB%B3%B5%EC%82%AC%EB%9E%80/"><![CDATA[<h2 id="방어적-복사란">방어적 복사란</h2>

<p>생성자를 통해 초기화 할 때, 새로운 객체로 감싸서 복사해주는 방법이다.
외부와 내부에서 주소값을 공유하는 인스턴스의 관계를 끊어주기 위함이다.
방어적 복사를 하지 않는다면, 외부(원본) List에서 리스트에 값을 추가할 시, 내부의 List에도 값이 추가 될 것이다.</p>

<h3 id="방어적-복사를-하지-않은-경우">방어적 복사를 하지 않은 경우</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="n">initialCards</span><span class="o">;</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cards</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">initialCards</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Card</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Symbol</span><span class="o">.</span><span class="na">DIAMOND</span><span class="o">,</span> <span class="nc">Denomination</span><span class="o">.</span><span class="na">FIVE</span><span class="o">));</span>
        <span class="n">initialCards</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Card</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Symbol</span><span class="o">.</span><span class="na">DIAMOND</span><span class="o">,</span> <span class="nc">Denomination</span><span class="o">.</span><span class="na">FOUR</span><span class="o">));</span>

        <span class="nc">Cards</span> <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cards</span><span class="o">(</span><span class="n">initialCards</span><span class="o">);</span>
      	<span class="n">initialCards</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Card</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Symbol</span><span class="o">.</span><span class="na">DIAMOND</span><span class="o">,</span> <span class="nc">Denomination</span><span class="o">.</span><span class="na">NINE</span><span class="o">));</span> <span class="c1">// 원본 리스트에서 값 추가</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Card</span> <span class="n">card</span> <span class="o">:</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// initialCards는 당연히 3개가 나올테고</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"card = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">", card content = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">.</span><span class="na">getDenomination</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span><span class="n">card</span><span class="o">.</span><span class="na">getSymbol</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Card</span> <span class="n">card</span> <span class="o">:</span> <span class="n">cards</span><span class="o">.</span><span class="na">getCards</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// initalCards에 카드를 추가하기 전에, Cards 객체를 먼저 만들었으니까 사이즈가 2이지 않을까?</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"card = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">", card content = "</span> <span class="o">+</span> <span class="n">card</span><span class="o">.</span><span class="na">getDenomination</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span><span class="n">card</span><span class="o">.</span><span class="na">getSymbol</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>이 실행 결과는 어떻게 될까?<br />
Cards 메서드로 조작하는 것이 아닌, Cards를 생성할 때, 인자로 들어올 <code class="language-plaintext highlighter-rouge">initialCards</code>리스트에서 새로운 Card 객체를 추가하였다.</p>

<p>인자로 들어올 리스트(외부)를 변경하니, Cards의 내부 List에서도 변경되었다.
이유가 뭘까?</p>

<p><img src="https://user-images.githubusercontent.com/67885363/158861419-22c3b5f3-cfe4-496b-9a51-c50cb401f449.png" alt="image" style="zoom:100%;" /></p>

<p>인자로 들어올 리스트 <code class="language-plaintext highlighter-rouge">initialCards</code>와 <code class="language-plaintext highlighter-rouge">Cards</code>의 필드인 <code class="language-plaintext highlighter-rouge">cards</code>가 주소를 공유하고 있기 때문이다.<br />
그러면, Cards 객체를 생성할 때, 원본과의 주소 공유를 끊어내보자.</p>

<p><br /></p>

<h3 id="방어적-복사를-한-경우">방어적 복사를 한 경우</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Cards</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">cards</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Cards</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="n">initialCards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cards</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">(</span><span class="n">initialCards</span><span class="o">);</span> <span class="c1">// new ArrayList&lt;&gt;()를 이용해 복사본을 만들었다.</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Card</span><span class="o">&gt;</span> <span class="nf">getCards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cards</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">new ArrayList&lt;&gt;(initialCards)</code>를 통해 새로운 주소값을 참조하도록 복사하였다.<br />
이렇게 되면 외부에서 넘겨주는 List와 내부적으로 사용하는 List가 참조하는 값이 다르기 때문에 외부에서 제어가 불가능해진다.</p>

<p><img src="https://user-images.githubusercontent.com/67885363/158861097-e4dd8fd0-6924-4462-8aaa-a28457abcf6f.png" alt="image" /></p>

<p>방어적 복사를 함으로써, 원본 리스트와 객체 내부 리스트의 참조 값이 달라지게 되었다.</p>

<p>그러면, <code class="language-plaintext highlighter-rouge">Cards</code>의 리스트는 외부의 변경에 안전하게 되었을까? 
아니다. <code class="language-plaintext highlighter-rouge">getCards().add()</code>를 한다면 새로운 값이 추가가 될 것이다.
이것 또한 막아주는 방법이 있다. 
이 내용은 다음 포스팅의 <code class="language-plaintext highlighter-rouge">copyOf()</code>와 <code class="language-plaintext highlighter-rouge">Collections.Unmodifiable</code>을 비교하면서 다루겠다.</p>]]></content><author><name>kun</name></author><category term="java" /><summary type="html"><![CDATA[방어적 복사란]]></summary></entry></feed>